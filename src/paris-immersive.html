<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gaurav Jiandani | Immersive Portfolio</title>
    <meta name="description" content="Principal Architect & Technical Partner - Immersive 3D Portfolio">

    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;400;500;600;700&family=Orbitron:wght@400;500;600;700;800;900&display=swap"
        rel="stylesheet">

    <style>
        *,
        *::before,
        *::after {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-loader: #e8e8e8;
            --bg-dark: #0a0a0a;
            --text-dark: #333333;
            --text-light: #ffffff;
            --accent-pink: #c9a0b8;
            --accent-warm: #ff9d5c;
            --accent-orange: #ff6b35;
            --accent-blue: #004e89;
            --accent-purple: #8b5cf6;
            --font-display: 'Orbitron', sans-serif;
            --font-body: 'Space Grotesk', sans-serif;
        }

        html {
            scroll-behavior: auto;
            /* native smooth fights our controlled scroll */
        }


        body {
            font-family: var(--font-body);
            background: var(--bg-loader);
            color: var(--text-dark);
            overflow: hidden;
            min-height: 100vh;
        }

        body.experience-active {
            background: var(--bg-dark);
            color: var(--text-light);
            overflow-x: hidden;
            overflow-y: auto;
        }

        /* LOADER */
        #loader {
            position: fixed;
            inset: 0;
            background:
                radial-gradient(900px 460px at 50% 45%, rgba(201, 160, 184, 0.25), transparent 65%),
                linear-gradient(180deg, #f0f0f0, var(--bg-loader));
            z-index: 9999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: opacity 1s ease, visibility 1s ease;
        }

        #loader.hidden {
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
        }

        .loader-icons {
            display: flex;
            align-items: flex-end;
            justify-content: center;
            gap: 2rem;
            margin-bottom: 1.5rem;
        }

        .loader-icon {
            stroke: #888;
            stroke-width: 1.5;
            fill: none;
            opacity: 0.5;
        }

        .loader-icon.active {
            stroke: var(--accent-pink);
            opacity: 1;
            filter: drop-shadow(0 10px 30px rgba(201, 160, 184, 0.25));
        }

        .start-button {
            padding: 1rem 4rem;
            font-family: var(--font-display);
            font-size: 1rem;
            font-weight: 600;
            letter-spacing: 0.3em;
            text-transform: uppercase;
            background: linear-gradient(180deg, var(--accent-pink), #b688a5);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.25s ease;
            margin-bottom: 1.25rem;
            position: relative;
            overflow: hidden;
            box-shadow: 0 14px 50px rgba(182, 136, 165, 0.28);
        }

        .start-button:disabled {
            opacity: 0.55;
            cursor: not-allowed;
            box-shadow: none;
        }

        .start-button::after {
            content: '';
            position: absolute;
            inset: -2px;
            background: radial-gradient(120px 60px at 30% 20%, rgba(255, 255, 255, 0.45), transparent 55%);
            opacity: 0.65;
            pointer-events: none;
        }

        .start-button:not(:disabled):hover {
            transform: translateY(-1px) scale(1.03);
            box-shadow: 0 18px 60px rgba(201, 160, 184, 0.45);
        }

        .loader-message {
            font-size: 0.875rem;
            letter-spacing: 0.1em;
            opacity: 0.6;
            text-align: center;
            margin-bottom: 1.25rem;
        }

        .loader-awards {
            display: flex;
            gap: 1.5rem;
            opacity: 0.4;
            font-size: 0.75rem;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            margin-top: 0.75rem;
        }

        /* Loader progress */
        .loader-progress {
            width: min(440px, 84vw);
            height: 10px;
            background: rgba(0, 0, 0, 0.08);
            border-radius: 999px;
            overflow: hidden;
            margin: 0.5rem 0 0.25rem;
        }

        .loader-progress-bar {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, rgba(201, 160, 184, 0.85), rgba(182, 136, 165, 0.95));
            transition: width 0.2s ease;
        }

        .loader-progress-text {
            font-size: 0.75rem;
            letter-spacing: 0.12em;
            opacity: 0.55;
            text-transform: uppercase;
            margin-bottom: 1.25rem;
        }

        /* NAVIGATION */
        .nav-fixed {
            position: fixed;
            top: 2rem;
            right: 2rem;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1.5rem;
            opacity: 0;
            transition: opacity 0.6s ease;
        }

        .nav-fixed.visible {
            opacity: 1;
        }

        .menu-toggle {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            cursor: pointer;
            color: white;
        }

        .menu-lines {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .menu-lines span {
            width: 28px;
            height: 2px;
            background: currentColor;
            transition: all 0.3s;
        }

        .menu-toggle:hover .menu-lines span:nth-child(2) {
            width: 18px;
        }

        .menu-label {
            font-size: 0.6rem;
            letter-spacing: 0.2em;
            text-transform: uppercase;
            opacity: 0.7;
        }

        /* 3D CANVAS */
        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
            opacity: 0;
            transition: opacity 1.5s ease;
        }

        #canvas-container.visible {
            opacity: 1;
        }

        /* SCROLL CONTAINER - Reduced height for better performance */
        .scroll-container {
            position: relative;
            z-index: 10;
            height: 800vh;
            /* Reduced from 2500vh for smoother scrolling */
            pointer-events: none;
        }

        /* UI LAYER */
        .ui-layer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            z-index: 50;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.8s ease;
        }

        .ui-layer.visible {
            opacity: 1;
        }

        /* TEXT PANELS - REAL UI (Glassmorphism) */
        .text-panel {
            position: absolute;
            max-width: 550px;
            padding: 2.5rem;
            opacity: 0;
            transform: translateY(60px);
            transition: all 0.8s cubic-bezier(0.16, 1, 0.3, 1);
            pointer-events: auto;

            background: rgba(10, 10, 15, 0.65);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-top: 1px solid rgba(255, 255, 255, 0.15);
            border-left: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 16px;
            box-shadow:
                0 4px 30px rgba(0, 0, 0, 0.3),
                0 0 0 1px rgba(255, 255, 255, 0.05);
        }

        .text-panel.active {
            opacity: 1;
            transform: translateY(0);
        }

        .text-panel .label {
            display: inline-block;
            font-size: 0.7rem;
            font-weight: 500;
            letter-spacing: 0.4em;
            text-transform: uppercase;
            color: var(--accent-orange);
            margin-bottom: 1rem;
            padding-left: 2rem;
            position: relative;
        }

        .text-panel .label::before {
            content: '';
            position: absolute;
            left: 0;
            top: 50%;
            width: 1.2rem;
            height: 1px;
            background: var(--accent-orange);
        }

        .text-panel h1,
        .text-panel h2 {
            font-family: var(--font-display);
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            line-height: 1.1;
            margin-bottom: 1.5rem;
        }

        .text-panel h1 {
            font-size: clamp(2.5rem, 6vw, 5rem);
        }

        .text-panel h2 {
            font-size: clamp(1.8rem, 4vw, 3rem);
        }

        /* Cinematic Text Reveal */
        .char {
            display: inline-block;
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.5s ease, transform 0.5s ease;
        }

        .text-panel.active .char {
            opacity: 1;
            transform: translateY(0);
        }

        .text-panel p {
            font-size: 1rem;
            line-height: 1.8;
            opacity: 0.85;
            max-width: 420px;
        }

        .text-panel .stats {
            display: flex;
            gap: 2.5rem;
            margin-top: 2rem;
            padding-top: 1.5rem;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .stat-value {
            font-family: var(--font-display);
            font-size: 2rem;
            font-weight: 700;
            color: var(--accent-orange);
        }

        .stat-label {
            font-size: 0.75rem;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            opacity: 0.6;
            margin-top: 0.25rem;
        }

        /* Panel positions */
        #panel-hero {
            left: 8%;
            top: 50%;
            transform: translateY(-50%);
        }

        #panel-hero.active {
            transform: translateY(-50%);
        }

        #panel-intro {
            right: 8%;
            top: 50%;
            transform: translateY(-50%);
            text-align: right;
        }

        #panel-intro.active {
            transform: translateY(-50%);
        }

        #panel-intro p {
            margin-left: auto;
        }

        #panel-journey {
            left: 8%;
            top: 45%;
        }

        #panel-architecture {
            right: 8%;
            top: 40%;
            text-align: right;
        }

        #panel-architecture p {
            margin-left: auto;
        }

        #panel-cloud {
            left: 8%;
            top: 50%;
            transform: translateY(-50%);
        }

        #panel-cloud.active {
            transform: translateY(-50%);
        }

        #panel-data {
            right: 8%;
            top: 45%;
            text-align: right;
        }

        #panel-data p {
            margin-left: auto;
        }

        #panel-skills {
            left: 8%;
            top: 40%;
        }

        #panel-projects {
            right: 8%;
            top: 50%;
            transform: translateY(-50%);
            text-align: right;
        }

        #panel-projects.active {
            transform: translateY(-50%);
        }

        #panel-projects p {
            margin-left: auto;
        }

        #panel-vision {
            left: 8%;
            top: 45%;
        }

        #panel-contact {
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
        }

        #panel-contact.active {
            transform: translate(-50%, -50%);
        }

        #panel-contact p {
            margin: 0 auto 2rem;
        }

        /* CTA BUTTON */
        .cta-button {
            display: inline-flex;
            align-items: center;
            gap: 1rem;
            padding: 1.2rem 3rem;
            font-family: var(--font-display);
            font-size: 0.85rem;
            font-weight: 600;
            letter-spacing: 0.2em;
            text-transform: uppercase;
            text-decoration: none;
            background: linear-gradient(135deg, var(--accent-orange), var(--accent-warm));
            color: white;
            border: none;
            border-radius: 60px;
            cursor: pointer;
            transition: all 0.4s ease;
        }

        .cta-button:hover {
            transform: translateY(-4px) scale(1.02);
            box-shadow: 0 20px 50px rgba(255, 107, 53, 0.4);
        }

        /* PROGRESS */
        .progress-container {
            position: fixed;
            left: 2.5rem;
            top: 50%;
            transform: translateY(-50%);
            z-index: 100;
            opacity: 0;
            transition: opacity 0.6s ease;
        }

        .progress-container.visible {
            opacity: 1;
        }

        .progress-track {
            width: 2px;
            height: 300px;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 2px;
            overflow: hidden;
        }

        .progress-thumb {
            width: 100%;
            height: 0%;
            background: linear-gradient(180deg, var(--accent-orange), var(--accent-warm));
            border-radius: 2px;
            transition: height 0.15s ease-out;
        }

        .progress-label {
            writing-mode: vertical-rl;
            font-size: 0.65rem;
            letter-spacing: 0.2em;
            text-transform: uppercase;
            opacity: 0.5;
            margin-top: 1rem;
            transform: rotate(180deg);
        }

        /* SECTION MARKERS */
        .section-markers {
            position: fixed;
            right: 2.5rem;
            top: 50%;
            transform: translateY(-50%);
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 0.8rem;
            opacity: 0;
            transition: opacity 0.6s ease;
        }

        .section-markers.visible {
            opacity: 1;
        }

        .section-marker {
            width: 8px;
            height: 8px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.4s ease;
            position: relative;
        }

        .section-marker::after {
            content: attr(data-label);
            position: absolute;
            right: 100%;
            top: 50%;
            transform: translateY(-50%);
            padding-right: 1rem;
            font-size: 0.6rem;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            white-space: nowrap;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .section-marker:hover::after {
            opacity: 0.6;
        }

        .section-marker:hover,
        .section-marker.active {
            background: var(--accent-orange);
            border-color: var(--accent-orange);
            transform: scale(1.4);
        }

        /* SCROLL HINT */
        .scroll-hint {
            position: fixed;
            bottom: 3rem;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.8rem;
            opacity: 0;
            z-index: 100;
            transition: opacity 0.5s ease;
        }

        .scroll-hint.visible {
            opacity: 1;
        }

        .scroll-hint.hidden {
            opacity: 0;
        }

        .scroll-hint-text {
            font-size: 0.7rem;
            letter-spacing: 0.3em;
            text-transform: uppercase;
            opacity: 0.6;
        }

        .scroll-hint-icon {
            width: 24px;
            height: 40px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 12px;
            position: relative;
        }

        .scroll-hint-icon::after {
            content: '';
            position: absolute;
            top: 8px;
            left: 50%;
            transform: translateX(-50%);
            width: 4px;
            height: 8px;
            background: var(--accent-orange);
            border-radius: 2px;
            animation: scrollBounce 2s ease-in-out infinite;
        }

        @keyframes scrollBounce {

            0%,
            100% {
                top: 8px;
                opacity: 1;
            }

            50% {
                top: 18px;
                opacity: 0.5;
            }
        }

        /* TECH TAGS */
        .tech-stack {
            display: flex;
            flex-wrap: wrap;
            gap: 0.8rem;
            margin-top: 1.5rem;
        }

        .tech-tag {
            padding: 0.5rem 1rem;
            font-size: 0.75rem;
            font-weight: 500;
            letter-spacing: 0.1em;
            background: rgba(255, 107, 53, 0.15);
            border: 1px solid rgba(255, 107, 53, 0.3);
            border-radius: 30px;
            color: var(--accent-warm);
        }

        /* PROJECT CARDS */
        .project-list {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            margin-top: 1.5rem;
        }

        .project-item {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 0.8rem 1.2rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            border-left: 3px solid var(--accent-orange);
            transition: all 0.3s ease;
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }

        .project-item:hover {
            transform: translateX(10px) scale(1.02);
            background: rgba(255, 255, 255, 0.1);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .project-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transform: translateX(-100%);
            transition: transform 0.6s ease;
        }

        .project-item:hover::before {
            transform: translateX(100%);
        }

        .project-item .title {
            font-weight: 600;
            font-size: 0.9rem;
        }

        .project-item .desc {
            font-size: 0.75rem;
            opacity: 0.7;
        }

        /* RESPONSIVE - Mobile First Enhancements */
        @media (max-width: 768px) {
            .text-panel {
                left: 4% !important;
                right: 4% !important;
                max-width: 92%;
                text-align: left !important;
                bottom: 12%;
                top: auto !important;
                transform: none !important;
                padding: 1.5rem;
                background: linear-gradient(to top,
                        rgba(10, 10, 10, 0.95) 0%,
                        rgba(10, 10, 10, 0.8) 70%,
                        transparent 100%);
                border-radius: 12px 12px 0 0;
            }

            .text-panel.active {
                transform: none !important;
            }

            .text-panel p {
                margin-left: 0 !important;
                font-size: 0.9rem;
                line-height: 1.6;
            }

            .text-panel h1 {
                font-size: clamp(1.8rem, 8vw, 2.8rem);
                margin-bottom: 1rem;
            }

            .text-panel h2 {
                font-size: clamp(1.4rem, 6vw, 2rem);
                margin-bottom: 1rem;
            }

            .text-panel .label {
                font-size: 0.6rem;
                letter-spacing: 0.3em;
                margin-bottom: 0.75rem;
            }

            .text-panel .stats {
                gap: 1.5rem;
                margin-top: 1.5rem;
                padding-top: 1rem;
                flex-wrap: wrap;
            }

            .stat-value {
                font-size: 1.5rem;
            }

            .stat-label {
                font-size: 0.65rem;
            }

            .tech-stack {
                gap: 0.5rem;
                margin-top: 1rem;
            }

            .tech-tag {
                padding: 0.4rem 0.8rem;
                font-size: 0.65rem;
            }

            .project-list {
                gap: 0.75rem;
                margin-top: 1rem;
            }

            .project-item {
                padding: 0.6rem 1rem;
            }

            .project-item .title {
                font-size: 0.8rem;
            }

            .project-item .desc {
                font-size: 0.65rem;
            }

            .cta-button {
                padding: 1rem 2rem;
                font-size: 0.75rem;
                width: 100%;
                justify-content: center;
            }

            /* Loader mobile adjustments */
            .loader-icons {
                gap: 1rem;
                flex-wrap: wrap;
                justify-content: center;
                padding: 0 1rem;
            }

            .loader-icons svg {
                width: 40px;
                height: auto;
            }

            .start-button {
                padding: 0.9rem 3rem;
                font-size: 0.9rem;
            }

            .loader-message {
                font-size: 0.75rem;
                padding: 0 1rem;
            }

            .loader-awards {
                font-size: 0.65rem;
                flex-wrap: wrap;
                justify-content: center;
                gap: 0.5rem;
            }

            /* Navigation mobile */
            .nav-fixed {
                top: 1rem;
                right: 1rem;
            }

            /* Progress bar mobile */
            .progress-container {
                left: 1rem;
            }

            .progress-track {
                height: 200px;
            }

            .progress-label {
                font-size: 0.55rem;
            }

            /* Section markers mobile */
            .section-markers {
                right: 1rem;
                gap: 0.6rem;
            }

            .section-marker {
                width: 6px;
                height: 6px;
            }

            .section-marker::after {
                display: none;
            }

            /* Scroll hint mobile */
            .scroll-hint {
                bottom: 1.5rem;
            }

            .scroll-hint-text {
                font-size: 0.6rem;
            }

            .scroll-hint-icon {
                width: 20px;
                height: 32px;
            }
        }

        @media (max-width: 380px) {
            .text-panel {
                padding: 1rem;
                bottom: 8%;
            }

            .text-panel h1 {
                font-size: 1.6rem;
            }

            .text-panel h2 {
                font-size: 1.3rem;
            }

            .text-panel p {
                font-size: 0.85rem;
            }

            .stat-value {
                font-size: 1.3rem;
            }
        }

        @media (max-width: 768px) and (orientation: landscape) {
            .text-panel {
                bottom: 5%;
                max-width: 60%;
                left: 5% !important;
                right: auto !important;
            }

            .text-panel h1,
            .text-panel h2 {
                font-size: 1.4rem;
            }

            .text-panel p {
                font-size: 0.8rem;
            }
        }

        @media (hover: none) and (pointer: coarse) {
            .project-item:hover {
                transform: none;
            }

            .project-item:active {
                transform: scale(0.98);
                background: rgba(255, 255, 255, 0.15);
            }

            .cta-button:hover {
                transform: none;
            }

            .cta-button:active {
                transform: scale(0.98);
            }

            .section-marker:hover {
                transform: none;
            }

            .section-marker:active,
            .section-marker.active {
                background: var(--accent-orange);
                border-color: var(--accent-orange);
                transform: scale(1.3);
            }
        }
    </style>
</head>

<body>
    <!-- Protocol Warning Script -->
    <script>
        if (window.location.protocol === 'file:') {
            document.body.innerHTML = `
                <div style="font-family: sans-serif; text-align: center; margin-top: 20%; color: #333;">
                    <h1 style="color: #e74c3c;">‚ö†Ô∏è Application Error</h1>
                    <p>This immersive portfolio uses ES Modules and cannot run directly from the file system.</p>
                    <div style="background: #f8f9fa; padding: 20px; display: inline-block; border-radius: 8px; text-align: left; margin-top: 20px;">
                        <strong>Quick Fix:</strong><br>
                        1. Open Terminal in the project folder<br>
                        2. Run: <code>npm run dev</code><br>
                        3. Open: <a href="http://localhost:5173/src/paris-immersive.html">http://localhost:5173/src/paris-immersive.html</a>
                    </div>
                </div>
            `;
            throw new Error('Using file:// protocol is not supported. Please run via local server.');
        }
    </script>

    <!-- LOADER -->
    <div id="loader">
        <div class="loader-icons">
            <svg class="loader-icon" width="50" height="65" viewBox="0 0 50 65">
                <rect x="10" y="25" width="30" height="35" rx="2" />
                <rect x="15" y="30" width="7" height="7" />
                <rect x="28" y="30" width="7" height="7" />
                <rect x="15" y="42" width="7" height="7" />
                <rect x="28" y="42" width="7" height="7" />
                <polygon points="25,5 5,25 45,25" />
            </svg>
            <svg class="loader-icon active" width="55" height="90" viewBox="0 0 55 90">
                <path d="M27.5 5 L27.5 82 M18 82 L37 82" />
                <path d="M27.5 5 C15 25 8 50 8 50 L47 50 C47 50 40 25 27.5 5" />
                <line x1="15" y1="35" x2="40" y2="35" />
                <line x1="18" y1="50" x2="37" y2="50" />
            </svg>
            <svg class="loader-icon" width="65" height="50" viewBox="0 0 65 50">
                <circle cx="12" cy="38" r="8" />
                <circle cx="52" cy="38" r="8" />
                <path d="M12 38 L20 30 L45 30 L52 38" />
                <rect x="22" y="20" width="20" height="10" rx="3" />
                <circle cx="32" cy="12" r="6" />
            </svg>
            <svg class="loader-icon" width="55" height="65" viewBox="0 0 55 65">
                <circle cx="27.5" cy="12" r="8" />
                <circle cx="10" cy="35" r="6" />
                <circle cx="45" cy="35" r="6" />
                <circle cx="15" cy="55" r="6" />
                <circle cx="40" cy="55" r="6" />
                <line x1="27.5" y1="20" x2="10" y2="29" />
                <line x1="27.5" y1="20" x2="45" y2="29" />
                <line x1="10" y1="41" x2="15" y2="49" />
                <line x1="45" y1="41" x2="40" y2="49" />
                <line x1="15" y1="55" x2="40" y2="55" />
            </svg>
        </div>

        <button class="start-button" id="startBtn" disabled>LOADING 0%</button>

        <div class="loader-progress" aria-hidden="true">
            <div class="loader-progress-bar" id="loaderBar"></div>
        </div>
        <div class="loader-progress-text" id="loaderPct">Loading 0%</div>
        <div class="loader-progress-text" id="loaderModel">Preparing assets‚Ä¶</div>

        <div class="loader-message">For the best experience<br>Turn your sound on / Switch to desktop</div>
        <div class="loader-awards">
            <span>Portfolio</span>
            <span>‚Ä¢</span>
            <span>Principal Architect</span>
            <span>‚Ä¢</span>
            <span>10+ Years</span>
        </div>
    </div>

    <!-- NAV -->
    <nav class="nav-fixed" id="nav">
        <div class="menu-toggle">
            <div class="menu-lines"><span></span><span></span><span></span></div>
            <span class="menu-label">menu</span>
        </div>
    </nav>

    <!-- 3D CANVAS -->
    <div id="canvas-container"></div>

    <!-- UI LAYER -->
    <div class="ui-layer" id="uiLayer">
        <!-- Section 1: Hero -->
        <div class="text-panel" id="panel-hero">
            <span class="label">Welcome</span>
            <h1>GAURAV<br>JIANDANI</h1>
            <p>Principal Architect & Technical Partner crafting scalable systems and immersive digital experiences.</p>
            <div class="stats">
                <div class="stat">
                    <div class="stat-value">10+</div>
                    <div class="stat-label">Years Exp</div>
                </div>
                <div class="stat">
                    <div class="stat-value">100K+</div>
                    <div class="stat-label">Daily Users</div>
                </div>
                <div class="stat">
                    <div class="stat-value">60M+</div>
                    <div class="stat-label">Records</div>
                </div>
            </div>
        </div>

        <!-- Section 2: Intro -->
        <div class="text-panel" id="panel-intro">
            <span class="label">The Beginning</span>
            <h2>FROM CODE<br>TO CRAFT</h2>
            <p>A decade of transforming complex challenges into elegant solutions. Every line of code tells a story of
                innovation.</p>
        </div>

        <!-- Section 3: Journey -->
        <div class="text-panel" id="panel-journey">
            <span class="label">The Road</span>
            <h2>BUILDING<br>THE FUTURE</h2>
            <p>From monoliths to microservices. From startups to enterprise. Each project shaped my understanding of
                scalable architecture.</p>
        </div>

        <!-- Section 4: Architecture -->
        <div class="text-panel" id="panel-architecture">
            <span class="label">Architecture</span>
            <h2>SYSTEMS<br>THAT SCALE</h2>
            <p>Designing distributed systems that handle millions of requests. Event-driven architectures that never
                sleep.</p>
        </div>

        <!-- Section 5: Cloud -->
        <div class="text-panel" id="panel-cloud">
            <span class="label">Cloud Native</span>
            <h2>ABOVE<br>THE CLOUDS</h2>
            <p>Multi-region deployments. Auto-scaling infrastructure. Kubernetes orchestration at global scale.</p>
            <div class="tech-stack">
                <span class="tech-tag">AWS</span>
                <span class="tech-tag">Docker</span>
                <span class="tech-tag">Kubernetes</span>
                <span class="tech-tag">Terraform</span>
            </div>
        </div>

        <!-- Section 6: Data -->
        <div class="text-panel" id="panel-data">
            <span class="label">Data</span>
            <h2>60 MILLION<br>RECORDS</h2>
            <p>Optimizing queries that touch billions of rows. Building data pipelines that process in real-time.</p>
        </div>

        <!-- Section 7: Skills -->
        <div class="text-panel" id="panel-skills">
            <span class="label">Expertise</span>
            <h2>TECHNICAL<br>MASTERY</h2>
            <p>Full-stack architecture with deep expertise across modern technologies.</p>
            <div class="tech-stack">
                <span class="tech-tag">Laravel</span>
                <span class="tech-tag">Python</span>
                <span class="tech-tag">Node.js</span>
                <span class="tech-tag">React</span>
                <span class="tech-tag">Vue.js</span>
                <span class="tech-tag">PostgreSQL</span>
                <span class="tech-tag">Redis</span>
                <span class="tech-tag">Shopify</span>
            </div>
        </div>

        <!-- Section 8: Projects -->
        <div class="text-panel" id="panel-projects">
            <span class="label">Impact</span>
            <h2>REAL<br>RESULTS</h2>
            <div class="project-list">
                <div class="project-item">
                    <div>
                        <div class="title">E-Commerce Platform</div>
                        <div class="desc">100K+ daily active users</div>
                    </div>
                </div>
                <div class="project-item">
                    <div>
                        <div class="title">SaaS Analytics</div>
                        <div class="desc">99.9% uptime, sub-100ms responses</div>
                    </div>
                </div>
                <div class="project-item">
                    <div>
                        <div class="title">Enterprise API</div>
                        <div class="desc">50M+ API calls daily</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Section 9: Vision -->
        <div class="text-panel" id="panel-vision">
            <span class="label">Vision</span>
            <h2>SCALABLE<br>EXCELLENCE</h2>
            <p>Building systems that don't just work‚Äîthey thrive under pressure. Architecture that anticipates
                tomorrow's demands.</p>
        </div>

        <!-- Section 10: Contact -->
        <div class="text-panel" id="panel-contact">
            <span class="label">Connect</span>
            <h2>LET'S BUILD<br>TOGETHER</h2>
            <p>Ready to transform your vision into reality?</p>
            <a href="mailto:jiandanigaurav@gmail.com" class="cta-button">
                <span>Start a Project</span>
                <svg width="20" height="20" viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M4 10h12M12 6l4 4-4 4" />
                </svg>
            </a>
        </div>
    </div>

    <!-- PROGRESS -->
    <div class="progress-container" id="progressContainer">
        <div class="progress-track">
            <div class="progress-thumb" id="progressThumb"></div>
        </div>
        <div class="progress-label">Scroll</div>
    </div>

    <!-- SECTION MARKERS - 10 sections -->
    <div class="section-markers" id="sectionMarkers">
        <div class="section-marker active" data-section="0" data-label="Welcome"></div>
        <div class="section-marker" data-section="1" data-label="Beginning"></div>
        <div class="section-marker" data-section="2" data-label="Journey"></div>
        <div class="section-marker" data-section="3" data-label="Architecture"></div>
        <div class="section-marker" data-section="4" data-label="Cloud"></div>
        <div class="section-marker" data-section="5" data-label="Data"></div>
        <div class="section-marker" data-section="6" data-label="Skills"></div>
        <div class="section-marker" data-section="7" data-label="Projects"></div>
        <div class="section-marker" data-section="8" data-label="Vision"></div>
        <div class="section-marker" data-section="9" data-label="Contact"></div>
    </div>

    <!-- SCROLL HINT -->
    <div class="scroll-hint" id="scrollHint">
        <div class="scroll-hint-icon"></div>
        <div class="scroll-hint-text">Scroll to explore</div>
    </div>

    <!-- SCROLL CONTAINER -->
    <div class="scroll-container" id="scrollContainer"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js';
        import { RGBELoader } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/loaders/RGBELoader.js';
        import { EffectComposer } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/postprocessing/EffectComposer.js';
        import { RenderPass } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/postprocessing/UnrealBloomPass.js';
        import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/loaders/GLTFLoader.js';
        import { DRACOLoader } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/loaders/DRACOLoader.js';
        import { MeshoptDecoder } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/libs/meshopt_decoder.module.js';
        import { siteContent } from './data/siteContent.js';
        import { Sky } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/objects/Sky.js';
        import { CloudManager, CLOUD_OCCLUSION_CONFIG, WorldStreamingManager, WORLD_STREAMING_CONFIG } from './three/CloudManager.js';


        console.log('üöÄ Script starting (Module Mode)...');
        // ‚úÖ Prevent browser from restoring previous scroll position on reload/back/forward
        if ('scrollRestoration' in history) history.scrollRestoration = 'manual';

        /*
         * WHAT CHANGED (cloud curtain load gate + safe camera path):
         * 1) Added strict hero/bg grouping with a bg visibility gate (hidden at HOME, revealed only after load+compile).
         * 2) Added deterministic cloud curtain modes: HOME baseline, transition strong mask, reveal fade, and fully off.
         * 3) Preload now includes mountain1.glb and runs through LoadingManager + GLTF cache; startup compileAsync reduces first-reveal stutter.
         * 4) Streaming thresholds were pushed farther so background chunks begin earlier, with existing staged fade preserved.
         * 5) Camera path is now defined by centralized safe waypoints and reinforced collision clearance; mouse never drives camera.
         */

        // =====================
        // SCENE CONFIG ‚Äî single place to tweak the visual look
        // =====================
        const SCENE_CONFIG = {
            // Renderer
            exposure: 1.1,
            exposureLow: 0.9,
            toneMapping: THREE.ACESFilmicToneMapping,
            toneMappingLow: THREE.LinearToneMapping,

            // Fog ‚Äî subtle blue-grey haze, NOT orange
            fogColor: 0x8a9bb5,
            fogDensity: 0.00012,

            // Sky shader
            skyTurbidity: 3.5,
            skyRayleigh: 0.8,
            skyMieCoefficient: 0.003,
            skyMieDirectionalG: 0.92,
            sunElevation: 8.0,
            sunAzimuth: 245,

            // Sun directional light
            sunLightColor: 0xffeedd,
            sunLightIntensity: 3.0,

            // Sun sprite
            sunSpriteScale: 180,
            sunSpriteOpacity: 0.6,
            sunSpriteDistance: 2800,

            // Hemisphere fill light
            hemiSkyColor: 0xffebc8,
            hemiGroundColor: 0x3a4a5c,
            hemiIntensity: 0.9,
            hemiIntensityLow: 1.25,

            // Ambient fill (prevents black silhouettes on LOW without env map)
            ambientColor: 0xfff5e6,
            ambientIntensity: 0.25,
            ambientIntensityLow: 0.65,

            // Grass
            grassColor: 0x5a8a4a,
            grassRepeat: 60,

            // Camera
            cameraDamping: 0.045,
            cameraDampingMax: 0.16,
            cameraMinY: 50,
            lookAtYClampMin: 50,
            lookAtYClampMax: 180,
        };


        // State
        const State = {
            started: false,
            progress: 0,
            targetProgress: 0,
            section: 0,
            isMobile: window.innerWidth < 768,
            lastFrameTime: 0,
            frameInterval: 1000 / 60, // Target 60 FPS

            // ‚úÖ quality tier (can change at runtime now)
            qualityTier: 'MEDIUM',       // safe default until auto-detect runs
            userForcedTier: null,        // null = allow auto-detect to work

            // ‚úÖ FPS monitoring (auto downgrade)
            fps: 30,
            fpsSamples: [],
            fpsLastSampleTs: 0,
            lowFpsStrikes: 0,

            // ‚úÖ Idle throttling
            lastInputTime: performance.now(),
            isIdle: false,

            // ‚úÖ Adaptive DPR
            currentDpr: 1.0,
            dprFloor: 0.75,
            streamingReadiness: 0
        };

        const URL_PARAMS = new URLSearchParams(window.location.search);
        const DEBUG_STREAMING = URL_PARAMS.get('debug') === '1';
        const DEBUG_CLOUD_PRELOAD = URL_PARAMS.get('cloudDebug') === '1';
        const DEFAULT_LAYOUT_SEED_LABEL = 'paris-city-v1';

        // Cloud transition + camera safety tuning.
        const HOME_CLOUD_RANGE = [0.0, 0.03];
        const START_CLOUD_RANGE = [0.03, 0.12];
        const CLEAR_CLOUD_RANGE = [0.12, 0.20];
        const END_CLOUD_RANGE = [1.0, 1.0]; // intentionally disabled for normal sections
        const CLOUD_DENSITY = 1.0;
        const CLOUD_OPACITY = 0.98;
        const HOME_CLOUD_OPACITY = 0.97;
        const MASK_CLOUD_OPACITY = 1.0;
        const CLOUD_FADE_DURATION = 0.8;
        const CLOUD_DRIFT_SPEEDS = { left: 0.06, right: 0.085, ambient: 0.038 };
        const CLOUD_HOME_DENSITY = 1.0;
        const CLOUD_TRANSITION_DENSITY = 0.95;
        const SECTION_TRIGGER_HYSTERESIS = 0.008;
        const CAMERA_SAFE_DISTANCE = 142;
        const BG_READY_THRESHOLD = 0.62;
        const BG_REVEAL_PROGRESS = 0.09;
        const BG_HIDE_PROGRESS = 0.035;
        const BG_REVEAL_TIMEOUT_MS = 2800;
        const HOME_FOG_DENSITY = 0.00072;
        const TRANSITION_FOG_DENSITY = 0.00095;
        const REVEAL_FOG_DENSITY = 0.00032;
        const MAX_RENDER_DPR = 1.25;
        const SceneState = Object.freeze({
            BOOT_LOADING: 'BOOT_LOADING',
            HOME_READY: 'HOME_READY',
            TRANSITION: 'TRANSITION',
            SECTION_READY: 'SECTION_READY'
        });
        const SCENE_FLOW_CONFIG = {
            bootTimeoutMs: 3200,
            homeTransitionMs: 1250,
            sectionTransitionMs: 900,
            revealAt: 0.62,
            homeReturnMaskUntil: 0.72,
            transitionSections: new Set([1])
        };

        const CLOUD_TRANSITION_CONFIG = {
            ...CLOUD_OCCLUSION_CONFIG,
            HOME_CLOUD_RANGE,
            START_CLOUD_RANGE,
            CLEAR_CLOUD_RANGE,
            END_CLOUD_RANGE,
            TRANSITION_CLOUD_RANGE: START_CLOUD_RANGE,
            CLOUD_DENSITY,
            CLOUD_OPACITY,
            HOME_CLOUD_OPACITY,
            MASK_CLOUD_OPACITY,
            CLOUD_FADE_DURATION,
            CLOUD_DRIFT_SPEEDS,
            CLOUD_HOME_DENSITY,
            CLOUD_TRANSITION_DENSITY,
            SECTION_TRIGGER_HYSTERESIS,
            cloudCurve: {
                homeStrength: 1.0,
                revealMinStrength: 0.16,
                postStrength: 0.0
            },
            depthOffset: {
                home: -520,
                transition: -240,
                section: -1200
            },
            revealReadinessThreshold: BG_READY_THRESHOLD
        };

        const STREAMING_ZONE_THRESHOLDS = {
            HERO: { enter: 0.0, exit: 0.14, preloadStart: 0.0 },
            MID: { enter: 0.06, exit: 0.9, preloadStart: 0.02 },
            FAR: { enter: 0.56, exit: 1.0, preloadStart: 0.36 }
        };

        const WORLD_STREAMING_RUNTIME_CONFIG = {
            ...WORLD_STREAMING_CONFIG,
            streamGate: CLOUD_TRANSITION_CONFIG.streamGate,
            readinessThreshold: CLOUD_TRANSITION_CONFIG.revealReadinessThreshold,
            zones: [
                { ...WORLD_STREAMING_CONFIG.zones[0], ...STREAMING_ZONE_THRESHOLDS.HERO },
                { ...WORLD_STREAMING_CONFIG.zones[1], ...STREAMING_ZONE_THRESHOLDS.MID },
                { ...WORLD_STREAMING_CONFIG.zones[2], ...STREAMING_ZONE_THRESHOLDS.FAR }
            ]
        };
        const FOG_TRANSITION_DAMP = 0.12;

        // Streaming distance bands + fade behavior (tune these first)
        const STREAMING_BANDS = {
            city: {
                // Preload from farther away, but still fade staged to avoid sudden pop-in.
                LOW: { farStart: 2480, midStart: 1620, nearStart: 910, nearFull: 570, fadeMsMin: 420, fadeMsMax: 720, hysteresis: 0.10, zoneSize: 360 },
                MEDIUM: { farStart: 3050, midStart: 1980, nearStart: 1080, nearFull: 680, fadeMsMin: 500, fadeMsMax: 800, hysteresis: 0.10, zoneSize: 400 },
                HIGH: { farStart: 3600, midStart: 2360, nearStart: 1260, nearFull: 780, fadeMsMin: 560, fadeMsMax: 860, hysteresis: 0.10, zoneSize: 440 }
            },
            tree: {
                LOW: { farStart: 1320, midStart: 900, nearStart: 560, nearFull: 350, fadeMsMin: 360, fadeMsMax: 660, hysteresis: 0.10, zoneSize: 240 },
                MEDIUM: { farStart: 1580, midStart: 1060, nearStart: 680, nearFull: 420, fadeMsMin: 420, fadeMsMax: 720, hysteresis: 0.10, zoneSize: 280 },
                HIGH: { farStart: 1840, midStart: 1240, nearStart: 790, nearFull: 490, fadeMsMin: 480, fadeMsMax: 780, hysteresis: 0.10, zoneSize: 320 }
            }
        };

        // Density tuning for near-start feel and vegetation clustering
        const DENSITY_TUNING = {
            cityStarterClusters: { LOW: 8, MEDIUM: 16, HIGH: 24 },
            treeClusterCount: { LOW: 10, MEDIUM: 18, HIGH: 28 },
            treeClusterMin: 3,
            treeClusterMax: 7
        };


        // =====================
        // ADAPTIVE QUALITY SYSTEM
        // =====================
        const QUALITY_PRESETS = {
            LOW: {
                particleCount: 180,
                cloudCount: 2,
                shadowMapSize: 0,
                maxLodDistance: 500,
                proxyDistance: 600,      // proxy starts here (must be > maxLodDistance)
                impostorDistance: 800,   // impostor starts here (must be > proxyDistance)
                cullDistance: 2200,      // impostors visible far out
                enableBloom: false,
                dprCap: 1.0,
                buildingCount: 24,
                terrainSegments: 24,
                riverSegments: 30,
                riverRadialSegments: 4,
                pathSegments: 20,
                grassAnisotropy: 4,
                treeCount: 64,
                treeLodCount: 24,
                treeProxyDistance: 170,
                treeCullDistance: 820,
                treeZoneSize: 260,
            },

            MEDIUM: {
                particleCount: 800,
                cloudCount: 6,
                shadowMapSize: 512,
                maxLodDistance: 800,
                proxyDistance: 900,
                impostorDistance: 1400,
                cullDistance: 3000,       // impostors visible far out
                enableBloom: true,
                dprCap: 1.15,
                buildingCount: 34,
                terrainSegments: 36,
                riverSegments: 42,
                riverRadialSegments: 6,
                pathSegments: 30,
                grassAnisotropy: 8,
                treeCount: 92,
                treeLodCount: 72,
                treeProxyDistance: 240,
                treeCullDistance: 1300,
                treeZoneSize: 300,
            },
            HIGH: {
                particleCount: 1200,
                cloudCount: 10,
                shadowMapSize: 1024,
                maxLodDistance: 1200,
                proxyDistance: 1400,
                impostorDistance: 2000,
                cullDistance: 3500,       // impostors visible far out
                enableBloom: true,
                dprCap: 1.25,
                buildingCount: 46,
                terrainSegments: 56,
                riverSegments: 60,
                riverRadialSegments: 8,
                pathSegments: 50,
                grassAnisotropy: 16,
                treeCount: 170,
                treeLodCount: 132,
                treeProxyDistance: 300,
                treeCullDistance: 1650,
                treeZoneSize: 340,
            }

        };

        function detectQualityTier() {
            // Mobile always gets LOW
            if (State.isMobile) return 'LOW';

            // MacBook Air detection - force LOW for thermal management
            const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
            const isMacBookAir = isMac && navigator.hardwareConcurrency <= 8 && /MacBookAir|MacBook Air/.test(navigator.userAgent);

            if (isMacBookAir) {
                console.log('üçé MacBook Air detected - forcing LOW quality for thermal management');
                return 'LOW';
            }

            // Estimate GPU capability
            const canvas = document.createElement('canvas');
            const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
            if (!gl) return 'LOW';

            const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
            const renderer = debugInfo ? gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) : '';

            // Check for known low-power / integrated GPUs (covers Apple Silicon, mobile, software renderers)
            const lowPowerGPUs = ['Intel', 'HD Graphics', 'UHD Graphics', 'Iris', 'Mali',
                'Adreno', 'PowerVR', 'Apple', 'Qualcomm', 'SwiftShader'];
            const isLowPower = lowPowerGPUs.some(gpu => renderer.includes(gpu));

            // Check device memory (if available)
            const memory = navigator.deviceMemory || 4;
            const cores = navigator.hardwareConcurrency || 4;

            // Only HIGH if proven discrete GPU
            if (memory >= 8 && cores >= 8 && /NVIDIA|AMD|RTX|GTX|Radeon/.test(renderer)) return 'HIGH';
            if (isLowPower || memory < 6 || cores < 6) return 'LOW';
            return 'MEDIUM';
        }

        function getQualitySettings() {
            return QUALITY_PRESETS[State.qualityTier] || QUALITY_PRESETS.MEDIUM;
        }

        // Auto-detect quality based on hardware (MacBook Air gets LOW)
        State.qualityTier = detectQualityTier();
        console.log('üéÆ Quality Tier:', State.qualityTier, '(auto-detected)');



        // Elements
        const loader = document.getElementById('loader');
        const startBtn = document.getElementById('startBtn');
        const nav = document.getElementById('nav');
        const canvasContainer = document.getElementById('canvas-container');
        const uiLayer = document.getElementById('uiLayer');
        const progressContainer = document.getElementById('progressContainer');
        const progressThumb = document.getElementById('progressThumb');
        const sectionMarkers = document.getElementById('sectionMarkers');
        const scrollHint = document.getElementById('scrollHint');
        const markers = document.querySelectorAll('.section-marker');
        const loaderBar = document.getElementById('loaderBar');
        const loaderPct = document.getElementById('loaderPct');
        const loaderModel = document.getElementById('loaderModel');
        let debugHud = null;
        let debugHudLastMs = 0;

        if (DEBUG_CLOUD_PRELOAD) {
            debugHud = document.createElement('div');
            debugHud.style.cssText = [
                'position:fixed',
                'left:12px',
                'top:12px',
                'z-index:2200',
                'padding:8px 10px',
                'background:rgba(0,0,0,0.62)',
                'color:#e8edf7',
                'font:12px/1.35 monospace',
                'border:1px solid rgba(255,255,255,0.22)',
                'border-radius:8px',
                'pointer-events:none',
                'white-space:pre'
            ].join(';');
            debugHud.textContent = 'debug hud booting...';
            document.body.appendChild(debugHud);
        }


        // Pointer camera parallax intentionally disabled (scroll-only cinematic camera).

        // Cinematic Text Splitter - preserves line breaks
        function splitText() {
            document.querySelectorAll('.text-panel h1, .text-panel h2').forEach(el => {
                const html = el.innerHTML;
                const lines = html.split(/<br\s*\/?>/gi);
                let charIndex = 0;

                const processedLines = lines.map(line => {
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = line;
                    const text = tempDiv.textContent || tempDiv.innerText || '';
                    return text.split('').map((char) => {
                        const delay = charIndex * 0.03;
                        charIndex++;
                        if (char === ' ') return `<span class="char" style="transition-delay:${delay}s">&nbsp;</span>`;
                        return `<span class="char" style="transition-delay:${delay}s">${char}</span>`;
                    }).join('');
                });

                el.innerHTML = processedLines.join('<br>');
            });
        }

        // Panels
        const panels = {
            hero: document.getElementById('panel-hero'),
            intro: document.getElementById('panel-intro'),
            journey: document.getElementById('panel-journey'),
            architecture: document.getElementById('panel-architecture'),
            cloud: document.getElementById('panel-cloud'),
            data: document.getElementById('panel-data'),
            skills: document.getElementById('panel-skills'),
            projects: document.getElementById('panel-projects'),
            vision: document.getElementById('panel-vision'),
            contact: document.getElementById('panel-contact')
        };

        // Three.js Setup
        let scene, camera, renderer, composer, bloomPass;
        let eiffelTower, scooter, particles, serverRacks, dataSpheres, codeBlocks, cityGroup, groundMesh;

        // Reusable frustum culling objects (avoid per-frame allocation)
        const _frustum = new THREE.Frustum();
        const _projMatrix = new THREE.Matrix4();
        const _sphere = new THREE.Sphere();

        // Scene groups tracking (visibility by section)
        const groups = {
            heroRoot: null,
            bgRoot: null,
            heroForeground: null,
            city: null,
            trees: null,
            mountains: null,
            eiffel: null,
            particles: null,
            scooter: null,
            serverRacks: null,
            dataSpheres: null,
            codeBlocks: null,
            clouds: null,
            terrain: null  // NEW: terrain with grass and river
        };
        const sceneCurves = {
            mainPath: null,
            river: null,
            riverHalfWidth: 90
        };
        let grassTerrainMesh = null;

        const treeLods = [];
        const treeZones = [];
        const treeProxyZones = [];
        const treeColliders = []; // { x, z, r }
        const streamTransitions = new Set(); // only objects currently fading

        let cityPlacedCount = 0;
        let treePlacedCount = 0;
        let cloudManager = null;
        let worldStreamingManager = null;
        let cloudCurtainState = 'HOME_IDLE';
        let previousCloudCurtainState = 'HOME_IDLE';
        let compileAllPromise = null;
        const sceneFlow = {
            state: SceneState.BOOT_LOADING,
            lastSection: 0,
            bootDeadlineMs: 0,
            transition: {
                active: false,
                fromSection: 0,
                toSection: 0,
                startMs: 0,
                durationMs: SCENE_FLOW_CONFIG.homeTransitionMs,
                deadlineMs: 0,
                direction: 1
            }
        };
        let bgRevealLocked = true;
        const bgGateState = {
            assetsLoaded: false,
            compiled: false,
            ready: false,
            revealDeadlineMs: 0,
            timedOut: false
        };

        const _groundRaycaster = new THREE.Raycaster();
        const _groundRayOrigin = new THREE.Vector3();
        const _groundRayDir = new THREE.Vector3(0, -1, 0);
        const _groundHits = [];
        const _readinessForward = new THREE.Vector3();
        const _readinessDir = new THREE.Vector3();
        const _cameraSafeDirection = new THREE.Vector2();
        const _cameraSafeTarget = new THREE.Vector3();

        const CAMERA_PATH_TUNING = {
            CAMERA_SAFE_DISTANCE,
            cameraGroundClearance: 24, // Keeps cinematic camera above terrain undulations.
            collisionBlend: 0.35, // Soft push avoids jitter when camera enters a keep-out bubble.
            maxCollisionPush: 22, // Caps one-frame correction while still resolving deep overlaps.
            lookAheadT: 0.014,
            lookAtForwardBlend: 0.24
        };


        // Materials - PBR Realism (tier-aware: LOW avoids expensive transmission passes)
        function createMaterials(tier) {
            const isLow = tier === 'LOW';
            const isMed = tier === 'MEDIUM';

            return {
                asphalt: new THREE.MeshStandardMaterial({
                    color: 0x151515,
                    roughness: 0.95,
                    metalness: 0.03
                }),
                limestone: new THREE.MeshStandardMaterial({
                    color: 0x7f7569,
                    roughness: 0.92,
                    metalness: 0.0
                }),
                zinc: new THREE.MeshStandardMaterial({
                    color: 0x353942,
                    roughness: 0.6,
                    metalness: 0.4
                }),
                iron: new THREE.MeshStandardMaterial({
                    color: 0x2b2b2b,
                    roughness: 0.7,
                    metalness: 0.4
                }),
                glass: isLow
                    ? new THREE.MeshStandardMaterial({ color: 0xaaccee, roughness: 0.15, metalness: 0.1, transparent: true, opacity: 0.35 })
                    : new THREE.MeshPhysicalMaterial({
                        color: 0xffffff,
                        metalness: 0.1,
                        roughness: 0.05,
                        transmission: isMed ? 0.5 : 0.9,
                        thickness: 0.5,
                    }),
                emissiveGreen: new THREE.MeshStandardMaterial({
                    color: 0x00ff00,
                    emissive: 0x00ff00,
                    emissiveIntensity: 2
                }),
                emissivePurple: new THREE.MeshStandardMaterial({
                    color: 0x8b5cf6,
                    roughness: 0.2,
                    metalness: 0.8,
                    emissive: 0x4c1d95,
                    emissiveIntensity: 0.8
                }),
                cheapGlass: isLow
                    ? new THREE.MeshStandardMaterial({ color: 0xaaccee, roughness: 0.25, transparent: true, opacity: 0.3 })
                    : new THREE.MeshPhysicalMaterial({
                        color: 0xffffff,
                        roughness: 0.18,
                        metalness: 0.0,
                        transmission: isMed ? 0.4 : 0.85,
                        thickness: 0.35,
                        ior: 1.45,
                        transparent: true
                    }),
                // Land and Environment Materials
                grass: new THREE.MeshStandardMaterial({
                    color: SCENE_CONFIG.grassColor,
                    roughness: 0.85,
                    metalness: 0.0,
                }),
                river: isLow
                    ? new THREE.MeshStandardMaterial({ color: 0x2a5a6a, roughness: 0.3, metalness: 0.15, transparent: true, opacity: 0.75 })
                    : new THREE.MeshPhysicalMaterial({
                        color: 0x2a5a6a,
                        metalness: 0.1,
                        roughness: 0.1,
                        transmission: isMed ? 0.3 : 0.6,
                        thickness: 2.0,
                        transparent: true,
                        opacity: 0.85,
                        envMapIntensity: 1.5
                    }),
                riverBed: new THREE.MeshStandardMaterial({
                    color: 0x3d4a3a,
                    roughness: 0.9,
                    metalness: 0.0
                }),
                dirt: new THREE.MeshStandardMaterial({
                    color: 0x5c4a3a,
                    roughness: 1.0,
                    metalness: 0.0
                }),
                path: new THREE.MeshStandardMaterial({
                    color: 0x9a8e80,
                    roughness: 0.92,
                    metalness: 0.0
                })
            };
        }
        let MATERIALS = createMaterials(State.qualityTier);

        // GLTF Loading (shared manager keeps preload progress deterministic).
        const loadingManager = new THREE.LoadingManager();
        const gltfLoader = new GLTFLoader(loadingManager);
        const dracoLoader = new DRACOLoader();
        dracoLoader.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.5/');
        gltfLoader.setDRACOLoader(dracoLoader);
        gltfLoader.setMeshoptDecoder(MeshoptDecoder);
        loadingManager.onStart = (_url, loaded, total) => {
            if (DEBUG_CLOUD_PRELOAD) console.log(`üì• [manager] start ${loaded}/${total}`);
        };
        loadingManager.onProgress = (_url, loaded, total) => {
            if (DEBUG_CLOUD_PRELOAD) console.log(`üì• [manager] progress ${loaded}/${total}`);
        };
        loadingManager.onLoad = () => {
            if (DEBUG_CLOUD_PRELOAD) console.log('‚úÖ [manager] all model requests completed');
        };

        const modelLoadingState = {
            totalModels: 10, // eiffel, scooter, building1-3, tree1-4, mountain1
            loadedModels: 0,
            currentModelProgress: 0,
            ready: false
        };


        const loadedModels = {
            eiffelTower: null,
            scooter: null,
            buildings: [],
            trees: [],
            mountains: []
        };
        const gltfCache = new Map(); // url -> gltf; avoids re-fetch/re-decode if reused

        function setLoaderProgress(pct) {
            const clamped = Math.max(0, Math.min(100, pct));
            if (loaderBar) loaderBar.style.width = `${clamped}%`;
            if (loaderPct) loaderPct.textContent = `Loading ${Math.round(clamped)}%`;
            if (startBtn && !modelLoadingState.ready) startBtn.textContent = `LOADING ${Math.round(clamped)}%`;
        }

        function computeOverallProgress() {
            const base = (modelLoadingState.loadedModels / modelLoadingState.totalModels) * 100;
            const current = (modelLoadingState.currentModelProgress / modelLoadingState.totalModels);
            return Math.min(100, base + current);
        }

        // R2 CDN URLs are content-addressed. If you update a model file,
        // append a ?v=<hash> query param to bust the CDN cache.
        const ASSET_BASE_URL = 'https://pub-311583034e5e4275b8fb5d11ad15c564.r2.dev';

        // If you want local dev, keep it empty '' or switch by environment.

        function assetUrl(p) {
            // allows '/file.glb' or 'file.glb'
            const clean = p.startsWith('/') ? p : `/${p}`;
            return ASSET_BASE_URL ? `${ASSET_BASE_URL}${clean}` : clean;
        }

        function loadModel(path, name) {
            return new Promise((resolve) => {
                const url = assetUrl(path);
                if (gltfCache.has(url)) {
                    if (DEBUG_CLOUD_PRELOAD) console.log(`üß† [cache-hit] ${name}`);
                    resolve(gltfCache.get(url));
                    return;
                }
                if (DEBUG_CLOUD_PRELOAD) console.log(`üì¶ [load-start] ${name}`);
                if (loaderModel) loaderModel.textContent = `Loading: ${name}`;

                gltfLoader.load(
                    url,
                    (gltf) => {
                        gltfCache.set(url, gltf);
                        modelLoadingState.loadedModels++;
                        modelLoadingState.currentModelProgress = 0;
                        if (DEBUG_CLOUD_PRELOAD) console.log(`‚úÖ [load-ready] ${name}`);
                        console.log(`‚úÖ Model loaded: ${name}`);
                        setLoaderProgress(computeOverallProgress());
                        resolve(gltf);
                    },
                    (progress) => {
                        if (progress.lengthComputable) {
                            modelLoadingState.currentModelProgress = (progress.loaded / progress.total) * 100;
                            setLoaderProgress(computeOverallProgress());
                        }
                    },
                    (error) => {
                        console.warn(`‚ö†Ô∏è Failed to load model ${name}:`, error);
                        if (DEBUG_CLOUD_PRELOAD) console.warn(`‚ö†Ô∏è [load-failed] ${name}`);
                        if (loaderModel) loaderModel.textContent = `Failed: ${name} (skipping)`;

                        modelLoadingState.loadedModels++;
                        modelLoadingState.currentModelProgress = 0;
                        setLoaderProgress(computeOverallProgress());
                        resolve(null);
                    }
                );
            });
        }



        async function loadAllModels() {
            console.log('üîÑ Loading 3D models...');
            if (startBtn) {
                startBtn.disabled = true;
                startBtn.textContent = 'LOADING 0%';
            }

            const [eiffelGltf, scooterGltf, building1, building2, building3, tree1, tree2, tree3, tree4, mountain1] = await Promise.all([
                loadModel('/3d-models/eiffel-tower.glb', 'Eiffel Tower'),
                loadModel('/3d-models/scooter.glb', 'Scooter'),
                loadModel('/3d-models/building1.glb', 'Building 1'),
                loadModel('/3d-models/building2.glb', 'Building 2'),
                loadModel('/3d-models/building3.glb', 'Building 3'),
                loadModel('/3d-models/tree1.glb', 'Tree 1'),
                loadModel('/3d-models/tree2.glb', 'Tree 2'),
                loadModel('/3d-models/tree3.glb', 'Tree 3'),
                loadModel('/3d-models/tree4.glb', 'Tree 4'),
                loadModel('/3d-models/mountain1.glb', 'Mountain 1')
            ]);

            loadedModels.eiffelTower = eiffelGltf;
            loadedModels.scooter = scooterGltf;
            loadedModels.buildings = [building1, building2, building3].filter(Boolean);
            loadedModels.trees = [tree1, tree2, tree3, tree4].filter(Boolean);
            loadedModels.mountains = [mountain1].filter(Boolean);


            modelLoadingState.ready = true;
            setLoaderProgress(100);

            if (startBtn) {
                startBtn.textContent = 'START';
                startBtn.disabled = false;
            }
            console.log(`‚úÖ Loaded ${loadedModels.buildings.length} building models`);
            console.log(`‚úÖ Loaded ${loadedModels.trees.length} tree models`);
            console.log(`‚úÖ Loaded ${loadedModels.mountains.length} mountain models`);
        }



        function getTightMeshBox(root) {
            const box = new THREE.Box3();
            const tmpBox = new THREE.Box3();

            root.updateMatrixWorld(true);

            let found = false;
            root.traverse((o) => {
                if (!o.isMesh || !o.geometry) return;

                // Ensure geometry has bounding box
                if (!o.geometry.boundingBox) o.geometry.computeBoundingBox();
                tmpBox.copy(o.geometry.boundingBox).applyMatrix4(o.matrixWorld);

                box.union(tmpBox);
                found = true;
            });

            // Fallback if model has no meshes
            if (!found) box.setFromObject(root);
            return box;
        }


        // -------------------------
        // NORMALIZATION HELPERS (FIX #1: building size + alignment)
        // -------------------------
        function normalizeToBaseline(object3D, opts = {}) {
            const {
                targetHeight = 150,
                clampMin = 0.08,
                clampMax = 80,
                minHeightBoost = 1.15, // small model boost
            } = opts;

            const wrapper = new THREE.Group();
            wrapper.add(object3D);

            wrapper.updateMatrixWorld(true);

            // ‚úÖ tight box (meshes only)
            const box = getTightMeshBox(wrapper);
            const size = box.getSize(new THREE.Vector3());

            const safeY = size.y || 1;
            let scale = targetHeight / safeY;
            scale = THREE.MathUtils.clamp(scale, clampMin, clampMax);

            wrapper.scale.setScalar(scale);
            wrapper.updateMatrixWorld(true);

            // ‚úÖ re-box after scaling (tight again)
            const box2 = getTightMeshBox(wrapper);

            // Center X/Z and ground Y
            const center2 = box2.getCenter(new THREE.Vector3());
            wrapper.position.x += -center2.x;
            wrapper.position.z += -center2.z;
            wrapper.position.y += -box2.min.y;

            wrapper.updateMatrixWorld(true);

            // ‚úÖ if still ‚Äútoo small‚Äù, boost a bit (fix tiny building)
            const boxFinal = getTightMeshBox(wrapper);
            const sizeFinal = boxFinal.getSize(new THREE.Vector3());
            if (sizeFinal.y < targetHeight * 0.65) {
                wrapper.scale.multiplyScalar(minHeightBoost);
                wrapper.updateMatrixWorld(true);

                const b3 = getTightMeshBox(wrapper);
                wrapper.position.y += -b3.min.y; // reground
                wrapper.updateMatrixWorld(true);
            }

            const finalBox = getTightMeshBox(wrapper);
            const finalSize = finalBox.getSize(new THREE.Vector3());

            return { wrapper, box: finalBox, size: finalSize, scale };
        }

        function ensureWorldGroups() {
            if (!scene) return;

            if (!groups.heroRoot) {
                groups.heroRoot = new THREE.Group();
                groups.heroRoot.name = 'heroGroup';
                scene.add(groups.heroRoot);
            }

            if (!groups.bgRoot) {
                groups.bgRoot = new THREE.Group();
                groups.bgRoot.name = 'bgGroup';
                groups.bgRoot.visible = false;
                scene.add(groups.bgRoot);
            }
        }

        function setBackgroundVisibility(visible) {
            if (!groups.bgRoot) return;
            groups.bgRoot.visible = !!visible;
            bgRevealLocked = !visible;
        }


        function makeProxyBuilding(size, baseMat) {
            const w = Math.max(10, size.x);
            const h = Math.max(20, size.y);
            const d = Math.max(10, size.z);

            const geo = new THREE.BoxGeometry(w, h, d);
            const mesh = new THREE.Mesh(geo, baseMat);
            mesh.castShadow = false;
            mesh.receiveShadow = true;
            mesh.position.y = h / 2;
            return mesh;
        }

        // -------------------------
        // REALISTIC TERRAIN with GRASS, RIVER, and LAND
        // -------------------------
        function createGround() {
            console.log('üåø Creating realistic terrain with grass and river...');

            const terrainGroup = new THREE.Group();
            terrainGroup.name = 'terrain';

            const worldSize = State.qualityTier === 'LOW' ? 4000 : 8000;
            const segments = getQualitySettings().terrainSegments;

            // Create base terrain geometry with noise-like variation
            const terrainGeo = new THREE.PlaneGeometry(worldSize, worldSize, segments, segments);
            terrainGeo.rotateX(-Math.PI / 2);

            // Add height variation to terrain (gentle rolling hills)
            const positions = terrainGeo.attributes.position;
            const vertexCount = positions.count;

            for (let i = 0; i < vertexCount; i++) {
                const x = positions.getX(i);
                const z = positions.getZ(i);

                // Create gentle rolling hills using sine waves
                // Keep center area (where Eiffel is) relatively flat
                const distFromCenter = Math.sqrt(x * x + z * z);
                const flattenFactor = Math.max(0, 1 - distFromCenter / 1500);

                let height = 0;

                // Large rolling hills
                height += Math.sin(x * 0.001) * Math.cos(z * 0.001) * 15;
                height += Math.sin(x * 0.002 + 100) * Math.cos(z * 0.002) * 8;

                // Smaller details
                height += Math.sin(x * 0.005) * Math.sin(z * 0.005) * 3;

                // Flatten center area for Eiffel Tower and main scene
                height = height * (1 - flattenFactor * 0.7);

                // Ensure minimum height
                height = Math.max(-5, height);

                positions.setY(i, height);
            }

            terrainGeo.computeVertexNormals();

            // Create the main grass terrain
            const grassMaterial = MATERIALS.grass.clone();

            // Try to load grass texture if available, else use color
            const textureLoader = new THREE.TextureLoader();
            const grassTextureUrl = assetUrl('/3d-models/grass.jpg');

            textureLoader.load(
                grassTextureUrl,
                (texture) => {
                    texture.wrapS = THREE.RepeatWrapping;
                    texture.wrapT = THREE.RepeatWrapping;
                    texture.repeat.set(SCENE_CONFIG.grassRepeat, SCENE_CONFIG.grassRepeat);
                    // Sharp at grazing angles ‚Äî use max anisotropy the GPU supports
                    const maxAniso = renderer?.capabilities?.getMaxAnisotropy?.() || 8;
                    texture.anisotropy = Math.min(maxAniso, getQualitySettings().grassAnisotropy || 8);
                    texture.minFilter = THREE.LinearMipmapLinearFilter;
                    texture.magFilter = THREE.LinearFilter;
                    texture.generateMipmaps = true;
                    grassMaterial.map = texture;
                    grassMaterial.needsUpdate = true;
                    console.log('‚úÖ Grass texture loaded');
                },
                undefined,
                () => {
                    console.log('‚ÑπÔ∏è No grass texture found, using procedural color');
                }
            );

            const terrain = new THREE.Mesh(terrainGeo, grassMaterial);
            terrain.receiveShadow = true;
            terrain.name = 'grassTerrain';
            terrainGroup.add(terrain);
            grassTerrainMesh = terrain;

            // Create River
            createRiver(terrainGroup);

            // Create dirt paths/roads
            createPaths(terrainGroup);

            ensureWorldGroups();
            groups.heroRoot.add(terrainGroup);
            groups.terrain = terrainGroup;

            console.log('‚úÖ Realistic terrain created with grass and river');
            return terrainGroup;
        }

        // Create a winding river through the scene
        function createRiver(parentGroup) {
            console.log('üåä Creating river...');

            const riverWidth = 180;
            const riverLength = 6000;
            const riverExtent = State.qualityTier === 'LOW' ? 1500 : 2500;
            const riverCurve = new THREE.CatmullRomCurve3([
                new THREE.Vector3(-riverExtent, -2, 800 * (riverExtent / 2500)),
                new THREE.Vector3(-riverExtent * 0.4, -3, 400 * (riverExtent / 2500)),
                new THREE.Vector3(0, -4, 0),
                new THREE.Vector3(riverExtent * 0.4, -3, -400 * (riverExtent / 2500)),
                new THREE.Vector3(riverExtent, -2, -800 * (riverExtent / 2500))
            ]);
            sceneCurves.river = riverCurve;
            sceneCurves.riverHalfWidth = riverWidth * 0.5;

            // Create river geometry from curve
            const qualityRiver = getQualitySettings();
            const riverSegments = qualityRiver.riverSegments;
            const riverGeo = new THREE.TubeGeometry(riverCurve, riverSegments, riverWidth / 2, qualityRiver.riverRadialSegments, false);

            // Flatten the tube to make it look like a river
            const positions = riverGeo.attributes.position;
            for (let i = 0; i < positions.count; i++) {
                const y = positions.getY(i);
                // Flatten vertically and lower slightly
                positions.setY(i, Math.max(-8, y * 0.1 - 4));
            }
            riverGeo.computeVertexNormals();

            const river = new THREE.Mesh(riverGeo, MATERIALS.river);
            river.name = 'river';
            river.receiveShadow = true;
            parentGroup.add(river);

            // Add river banks (slightly elevated dirt)
            const bankGeo = new THREE.TubeGeometry(riverCurve, riverSegments, riverWidth / 2 + 15, qualityRiver.riverRadialSegments, false);
            const bankPositions = bankGeo.attributes.position;
            for (let i = 0; i < bankPositions.count; i++) {
                const y = bankPositions.getY(i);
                bankPositions.setY(i, Math.max(-3, y * 0.15 + 1));
            }
            bankGeo.computeVertexNormals();

            const riverBank = new THREE.Mesh(bankGeo, MATERIALS.riverBed);
            riverBank.name = 'riverBank';
            riverBank.receiveShadow = true;
            parentGroup.add(riverBank);

            console.log('‚úÖ River created');
        }

        // Create dirt paths/roads
        function createPaths(parentGroup) {
            console.log('üõ§Ô∏è Creating paths...');

            // Main path leading to Eiffel
            const pathCurve = new THREE.CatmullRomCurve3([
                new THREE.Vector3(0, 0.5, 600),
                new THREE.Vector3(0, 0.5, 300),
                new THREE.Vector3(0, 0.5, 0),
                new THREE.Vector3(0, 0.5, -200)
            ]);
            sceneCurves.mainPath = pathCurve;

            const pathGeo = new THREE.TubeGeometry(pathCurve, getQualitySettings().pathSegments, 25, 4, false);

            // Flatten path
            const positions = pathGeo.attributes.position;
            for (let i = 0; i < positions.count; i++) {
                positions.setY(i, 0.8);
            }
            pathGeo.computeVertexNormals();

            const mainPath = new THREE.Mesh(pathGeo, MATERIALS.path);
            mainPath.name = 'mainPath';
            mainPath.receiveShadow = true;
            parentGroup.add(mainPath);

            console.log('‚úÖ Paths created');
        }

        function getGroundY(x, z, fallbackY = 0) {
            if (!grassTerrainMesh) return fallbackY;
            _groundRayOrigin.set(x, 2000, z);
            _groundHits.length = 0;
            _groundRaycaster.near = 0;
            _groundRaycaster.far = 5000;
            _groundRaycaster.set(_groundRayOrigin, _groundRayDir);
            _groundRaycaster.intersectObject(grassTerrainMesh, false, _groundHits);
            if (_groundHits.length > 0) return _groundHits[0].point.y;
            return fallbackY;
        }

        function sampleCurve2D(curve, sampleCount = 160) {
            const points = [];
            if (!curve) return points;
            for (let i = 0; i <= sampleCount; i++) {
                const p = curve.getPointAt(i / sampleCount);
                points.push({ x: p.x, z: p.z });
            }
            return points;
        }

        function distSqToSegment2D(px, pz, ax, az, bx, bz) {
            const abx = bx - ax;
            const abz = bz - az;
            const apx = px - ax;
            const apz = pz - az;
            const abLenSq = abx * abx + abz * abz || 1;
            const t = THREE.MathUtils.clamp((apx * abx + apz * abz) / abLenSq, 0, 1);
            const qx = ax + abx * t;
            const qz = az + abz * t;
            const dx = px - qx;
            const dz = pz - qz;
            return dx * dx + dz * dz;
        }

        function minDistanceSqToPolyline2D(x, z, points) {
            if (!points || points.length < 2) return Infinity;
            let best = Infinity;
            for (let i = 0; i < points.length - 1; i++) {
                const a = points[i];
                const b = points[i + 1];
                const d2 = distSqToSegment2D(x, z, a.x, a.z, b.x, b.z);
                if (d2 < best) best = d2;
            }
            return best;
        }

        function createHeroForegroundSet() {
            ensureWorldGroups();
            if (!groups.heroRoot) return null;

            if (groups.heroForeground && groups.heroForeground.parent) {
                groups.heroForeground.parent.remove(groups.heroForeground);
            }

            const heroForeground = new THREE.Group();
            heroForeground.name = 'heroForeground';
            // Keep HOME foreground minimal and clean: avoid near placeholder-like buildings.

            const treeAnchors = [
                { x: -90, z: 220, scale: 1.05 },
                { x: 110, z: 180, scale: 0.92 },
                { x: -160, z: 70, scale: 0.86 },
                { x: 170, z: 40, scale: 0.78 }
            ];

            if (loadedModels.trees && loadedModels.trees.length > 0) {
                for (let i = 0; i < treeAnchors.length; i++) {
                    const anchor = treeAnchors[i];
                    const src = loadedModels.trees[i % loadedModels.trees.length];
                    if (!src?.scene) continue;

                    const clone = src.scene.clone(true);
                    improveTextureFiltering(clone);
                    const normalized = normalizeToBaseline(clone, {
                        targetHeight: 18,
                        clampMin: 0.05,
                        clampMax: 20,
                        minHeightBoost: 1.08
                    });
                    normalized.wrapper.scale.multiplyScalar(anchor.scale);
                    normalized.wrapper.position.set(anchor.x, getGroundY(anchor.x, anchor.z, 0), anchor.z);
                    normalized.wrapper.rotation.y = Math.random() * Math.PI * 2;
                    heroForeground.add(normalized.wrapper);
                }
            }

            groups.heroForeground = heroForeground;
            groups.heroRoot.add(heroForeground);
            return heroForeground;
        }

        function createTrees() {
            console.log('üå≥ Building trees (streamed clusters + river + boulevard)...');

            if (groups.trees && groups.trees.parent) {
                groups.trees.parent.remove(groups.trees);
            }

            treeLods.length = 0;
            treeZones.length = 0;
            treeProxyZones.length = 0;
            treeColliders.length = 0;

            const treeGroup = new THREE.Group();
            treeGroup.name = 'trees';
            groups.trees = treeGroup;

            const quality = getQualitySettings();
            const bands = getStreamingBands('tree');
            const totalTarget = quality.treeCount || 160;
            const streamedTarget = Math.min(totalTarget, Math.max(20, quality.treeLodCount || totalTarget));
            const rand = makeLayoutRng(_baseTreeSeed);

            if (grassTerrainMesh) grassTerrainMesh.updateMatrixWorld(true);

            const pathSamples = sampleCurve2D(sceneCurves.mainPath, 180);
            const riverSamples = sampleCurve2D(sceneCurves.river, 220);
            const pathHalfWidth = 25;
            const riverHalfWidth = Math.max(82, sceneCurves.riverHalfWidth || 90);
            const riverSafeClearance = riverHalfWidth + 16;

            const templates = [];
            if (loadedModels.trees && loadedModels.trees.length > 0) {
                for (let i = 0; i < loadedModels.trees.length; i++) {
                    const gltf = loadedModels.trees[i];
                    if (!gltf || !gltf.scene) continue;

                    const raw = gltf.scene.clone(true);
                    improveTextureFiltering(raw);
                    raw.traverse((child) => {
                        if (!child.isMesh) return;
                        child.castShadow = false;
                        child.receiveShadow = true;
                        const mats = Array.isArray(child.material) ? child.material : [child.material];
                        mats.forEach((m) => {
                            if (!m) return;
                            if (m.metalness !== undefined) m.metalness = Math.min(m.metalness, 0.12);
                            if (m.roughness !== undefined) m.roughness = Math.max(m.roughness, 0.6);
                            m.fog = true;
                            m.needsUpdate = true;
                        });
                    });

                    const targetHeight = 18 + i * 3;
                    const normalized = normalizeToBaseline(raw, {
                        targetHeight,
                        clampMin: 0.05,
                        clampMax: 24,
                        minHeightBoost: 1.08
                    });
                    templates.push({ hi: normalized.wrapper, size: normalized.size });
                }
            }
            if (templates.length === 0) {
                console.warn('‚ö†Ô∏è Tree GLBs unavailable. Using proxy-only tree streaming.');
            }

            const proxyTrunkGeo = new THREE.CylinderGeometry(0.45, 0.68, 8, 7);
            const proxyLeafGeo = new THREE.ConeGeometry(5.2, 12.8, 8);
            const proxySilGeo = new THREE.ConeGeometry(5.4, 13.2, 6);

            const proxyTrunkMat = new THREE.MeshStandardMaterial({
                color: 0x5d442a,
                roughness: 0.95,
                metalness: 0.0,
                fog: true
            });
            const proxyLeafMat = new THREE.MeshStandardMaterial({
                color: 0x3f6f3a,
                roughness: 0.94,
                metalness: 0.0,
                fog: true
            });
            const treeSilhouetteMat = new THREE.MeshBasicMaterial({
                color: 0x2f4630,
                fog: true
            });

            function makeTreeProxyNode(scaleFactor = 1) {
                const proxy = new THREE.Group();
                const trunk = new THREE.Mesh(proxyTrunkGeo, proxyTrunkMat);
                const crown = new THREE.Mesh(proxyLeafGeo, proxyLeafMat);
                trunk.position.y = 4;
                crown.position.y = 14;
                trunk.castShadow = false;
                crown.castShadow = false;
                trunk.receiveShadow = true;
                crown.receiveShadow = true;
                proxy.add(trunk);
                proxy.add(crown);
                proxy.scale.setScalar(scaleFactor);
                return proxy;
            }

            function makeTreeSilhouetteNode(scaleFactor = 1) {
                const silhouette = new THREE.Group();
                const body = new THREE.Mesh(proxySilGeo, treeSilhouetteMat);
                body.position.y = 7;
                body.scale.set(0.95, 1.12, 0.95);
                silhouette.add(body);
                silhouette.scale.setScalar(scaleFactor);
                return silhouette;
            }

            function intersectsCircles(x, z, r, circles, extraPad = 0) {
                for (let i = 0; i < circles.length; i++) {
                    const c = circles[i];
                    const dx = x - c.x;
                    const dz = z - c.z;
                    const rr = r + c.r + extraPad;
                    if (dx * dx + dz * dz < rr * rr) return true;
                }
                return false;
            }

            function isTreeSpotValid(x, z, r, opts = {}) {
                const worldLimit = State.qualityTier === 'LOW' ? 1900 : 3900;
                if (Math.abs(x) > worldLimit || Math.abs(z) > worldLimit) return false;

                const dxE = x - EIFFEL_XZ.x;
                const dzE = z - EIFFEL_XZ.y;
                const keepOut = EIFFEL_KEEP_OUT_R + 36 + r;
                if (dxE * dxE + dzE * dzE < keepOut * keepOut) return false;

                if (intersectsCircles(x, z, r, cityColliders, 2)) return false;
                if (intersectsCircles(x, z, r, treeColliders, 5)) return false;

                if (opts.avoidPath !== false && pathSamples.length > 1) {
                    const pathD2 = minDistanceSqToPolyline2D(x, z, pathSamples);
                    const minPath = pathHalfWidth + 8 + r;
                    if (pathD2 < minPath * minPath) return false;
                }

                if (riverSamples.length > 1) {
                    const riverD2 = minDistanceSqToPolyline2D(x, z, riverSamples);
                    const minRiver = (opts.riverClearance !== undefined ? opts.riverClearance : riverSafeClearance) + r;
                    if (riverD2 < minRiver * minRiver) return false;
                }

                return true;
            }

            const placements = [];
            function addPlacement(x, z, r, zone) {
                const y = getGroundY(x, z, 0);
                const placement = {
                    x,
                    y,
                    z,
                    r,
                    zone,
                    rotation: rand() * Math.PI * 2,
                    scale: 0.88 + rand() * 0.3,
                    templateIndex: templates.length ? Math.floor(rand() * templates.length) : -1
                };
                placements.push(placement);
                treeColliders.push({ x, z, r });
                return placement;
            }

            function addCluster(centerX, centerZ, count, spread, zone, opts = {}) {
                for (let i = 0; i < count && placements.length < totalTarget; i++) {
                    const angle = rand() * Math.PI * 2;
                    const radial = spread * (0.28 + rand() * 0.92);
                    const x = centerX + Math.cos(angle) * radial + (rand() - 0.5) * 5;
                    const z = centerZ + Math.sin(angle) * radial + (rand() - 0.5) * 5;
                    const r = 6 + rand() * 3.8;
                    if (isTreeSpotValid(x, z, r, opts)) addPlacement(x, z, r, zone);
                }
            }

            const clusterMin = DENSITY_TUNING.treeClusterMin;
            const clusterMax = DENSITY_TUNING.treeClusterMax;

            // A) Boulevard clusters
            if (sceneCurves.mainPath) {
                const len = sceneCurves.mainPath.getLength();
                let walk = 35;
                while (walk < len - 24 && placements.length < totalTarget) {
                    const t = walk / len;
                    const p = sceneCurves.mainPath.getPointAt(t);
                    const tangent = sceneCurves.mainPath.getTangentAt(t);
                    const side = new THREE.Vector3(-tangent.z, 0, tangent.x).normalize();
                    const sideOffset = 35 + rand() * 20;
                    const jitter = (rand() - 0.5) * 12;
                    const firstSign = rand() > 0.5 ? 1 : -1;
                    const clusterSize = clusterMin + Math.floor(rand() * (clusterMax - clusterMin + 1));

                    const xA = p.x + side.x * sideOffset * firstSign + jitter;
                    const zA = p.z + side.z * sideOffset * firstSign + jitter;
                    addCluster(xA, zA, clusterSize, 20 + rand() * 8, 'boulevard', { avoidPath: false, riverClearance: riverSafeClearance });

                    const xB = p.x - side.x * sideOffset * firstSign - jitter;
                    const zB = p.z - side.z * sideOffset * firstSign - jitter;
                    addCluster(xB, zB, Math.max(3, clusterSize - 1), 18 + rand() * 7, 'boulevard', { avoidPath: false, riverClearance: riverSafeClearance });

                    walk += 58 + rand() * 22;
                }
            }

            // B) River bank clusters
            if (sceneCurves.river) {
                const len = sceneCurves.river.getLength();
                let walk = 42;
                let sideSwitch = 1;
                while (walk < len - 30 && placements.length < totalTarget) {
                    const t = walk / len;
                    const p = sceneCurves.river.getPointAt(t);
                    const tangent = sceneCurves.river.getTangentAt(t);
                    const side = new THREE.Vector3(-tangent.z, 0, tangent.x).normalize();
                    sideSwitch *= -1;
                    const sign = rand() > 0.45 ? sideSwitch : -sideSwitch;
                    const offset = riverHalfWidth + 34 + rand() * 34;
                    const cx = p.x + side.x * offset * sign;
                    const cz = p.z + side.z * offset * sign;
                    const clusterSize = 3 + Math.floor(rand() * 4);
                    addCluster(cx, cz, clusterSize, 19 + rand() * 10, 'river', { avoidPath: true, riverClearance: riverSafeClearance });
                    walk += 130 + rand() * 60;
                }
            }

            // C) Block/perimeter clusters around city and park patches
            const targetClusters = DENSITY_TUNING.treeClusterCount[State.qualityTier] || 20;
            for (let c = 0; c < targetClusters && placements.length < totalTarget; c++) {
                let cx;
                let cz;
                if (cityColliders.length > 0 && rand() < 0.75) {
                    const b = cityColliders[Math.floor(rand() * cityColliders.length)];
                    const a = rand() * Math.PI * 2;
                    const d = b.r + 22 + rand() * 80;
                    cx = b.x + Math.cos(a) * d;
                    cz = b.z + Math.sin(a) * d;
                } else {
                    const ringR = (State.isMobile ? 760 : 980) + rand() * (State.isMobile ? 420 : 960);
                    const a = rand() * Math.PI * 2;
                    cx = Math.cos(a) * ringR;
                    cz = -520 + Math.sin(a) * ringR;
                }
                const clusterSize = clusterMin + Math.floor(rand() * (clusterMax - clusterMin + 1));
                addCluster(cx, cz, clusterSize, 24 + rand() * 10, 'block', { avoidPath: true, riverClearance: riverSafeClearance + 4 });
            }

            // Deterministic recovery to guarantee tier budgets.
            let safetyPass = 0;
            while (placements.length < totalTarget && safetyPass < totalTarget * 90) {
                safetyPass++;
                const a = rand() * Math.PI * 2;
                const d = (State.isMobile ? 800 : 1020) + rand() * (State.isMobile ? 520 : 1180);
                const x = Math.cos(a) * d;
                const z = -520 + Math.sin(a) * d;
                const r = 6 + rand() * 3.2;
                if (isTreeSpotValid(x, z, r, { avoidPath: true, riverClearance: riverSafeClearance + 4 })) {
                    addPlacement(x, z, r, 'recovery');
                }
            }

            const streamedPlacements = placements.slice(0, streamedTarget);
            const instancedPlacements = placements.slice(streamedPlacements.length);

            for (let i = 0; i < streamedPlacements.length; i++) {
                const p = streamedPlacements[i];

                let hiNode;
                if (templates.length > 0) {
                    const template = templates[p.templateIndex % templates.length];
                    hiNode = template.hi.clone(true);
                    hiNode.scale.multiplyScalar(p.scale);
                    hiNode.updateMatrixWorld(true);
                    const hiBox = getTightMeshBox(hiNode);
                    hiNode.position.y += -hiBox.min.y;
                    hiNode.updateMatrixWorld(true);
                } else {
                    hiNode = makeTreeProxyNode(p.scale);
                }

                const proxyNode = makeTreeProxyNode(p.scale * 0.96);
                const silhouetteNode = makeTreeSilhouetteNode(p.scale * 0.96);
                const stream = buildStreamObject('tree', hiNode, proxyNode, silhouetteNode, rand);
                stream.position.set(p.x, p.y, p.z);
                stream.rotation.y = p.rotation;

                treeGroup.add(stream);
                treeLods.push(stream);
            }

            // Keep a cheap instanced fallback for distant vegetation mass.
            if (instancedPlacements.length > 0) {
                const zoneSize = bands.zoneSize;
                const zoneMap = new Map();
                for (let i = 0; i < instancedPlacements.length; i++) {
                    const p = instancedPlacements[i];
                    const kx = Math.floor(p.x / zoneSize);
                    const kz = Math.floor(p.z / zoneSize);
                    const key = `${kx},${kz}`;
                    if (!zoneMap.has(key)) {
                        zoneMap.set(key, {
                            items: [],
                            center: new THREE.Vector3((kx + 0.5) * zoneSize, 35, (kz + 0.5) * zoneSize),
                            radius: zoneSize * 0.92
                        });
                    }
                    zoneMap.get(key).items.push(p);
                }

                const tmpPos = new THREE.Vector3();
                const tmpScale = new THREE.Vector3();
                const tmpQuat = new THREE.Quaternion();
                const tmpMat = new THREE.Matrix4();
                const up = new THREE.Vector3(0, 1, 0);

                zoneMap.forEach((zone) => {
                    const count = zone.items.length;
                    const zoneGroup = new THREE.Group();
                    zoneGroup.name = 'treeProxyZone';

                    const trunkInst = new THREE.InstancedMesh(proxyTrunkGeo, proxyTrunkMat, count);
                    const crownInst = new THREE.InstancedMesh(proxyLeafGeo, proxyLeafMat, count);
                    trunkInst.frustumCulled = true;
                    crownInst.frustumCulled = true;

                    for (let i = 0; i < count; i++) {
                        const p = zone.items[i];
                        tmpQuat.setFromAxisAngle(up, p.rotation);
                        tmpScale.set(p.scale, p.scale, p.scale);

                        tmpPos.set(p.x, p.y + 4 * p.scale, p.z);
                        tmpMat.compose(tmpPos, tmpQuat, tmpScale);
                        trunkInst.setMatrixAt(i, tmpMat);

                        tmpPos.set(p.x, p.y + 14 * p.scale, p.z);
                        tmpMat.compose(tmpPos, tmpQuat, tmpScale);
                        crownInst.setMatrixAt(i, tmpMat);
                    }

                    trunkInst.instanceMatrix.needsUpdate = true;
                    crownInst.instanceMatrix.needsUpdate = true;
                    trunkInst.computeBoundingSphere();
                    crownInst.computeBoundingSphere();

                    zoneGroup.add(trunkInst);
                    zoneGroup.add(crownInst);
                    zoneGroup.visible = false;
                    treeGroup.add(zoneGroup);

                    treeProxyZones.push({
                        group: zoneGroup,
                        center: zone.center,
                        radius: zone.radius,
                        farStart: bands.farStart
                    });
                });
            }

            const zones = buildStreamZonesFromItems(treeLods, bands.zoneSize, 38);
            treeZones.length = 0;
            for (let i = 0; i < zones.length; i++) treeZones.push(zones[i]);

            treePlacedCount = placements.length;
            ensureWorldGroups();
            groups.bgRoot.add(treeGroup);
            console.log(`üå≥ Trees built: ${treePlacedCount} (tier=${State.qualityTier})`);
            if (DEBUG_STREAMING) {
                console.log(`üß™ Trees debug | streamed=${streamedPlacements.length} instanced=${instancedPlacements.length}`);
            }
            return treeGroup;
        }


        // -------------------------
        // City Generation (FIX #1 + FIX #2)
        // - Normalize all buildings
        // - LOD: near GLB, far proxy
        // - Visibility culling by distance
        // -------------------------
        const EIFFEL_XZ = new THREE.Vector2(0, -300);
        const EIFFEL_KEEP_OUT_R = 260; // adjust if needed

        const cityInstances = [];
        const cityLods = []; // Direct LOD array ‚Äî avoids traverse() every frame
        const cityZones = []; // Spatial zones for coarse frustum culling
        const cityColliders = []; // { x, z, r }

        // ---- Seeded PRNG for deterministic city/tree layout ----
        function hashStringToSeed(str) {
            let h = 2166136261 >>> 0; // FNV-1a
            for (let i = 0; i < str.length; i++) {
                h ^= str.charCodeAt(i);
                h = Math.imul(h, 16777619);
            }
            return h >>> 0;
        }

        function makeRng(seed) {
            let s = seed >>> 0;
            return function () {
                s = (s + 0x6D2B79F5) >>> 0;
                let t = Math.imul(s ^ (s >>> 15), 1 | s);
                t ^= t + Math.imul(t ^ (t >>> 7), 61 | t);
                return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
            };
        }

        function resolveLayoutSeed() {
            const seedParam = URL_PARAMS.get('seed');
            if (!seedParam) return hashStringToSeed(DEFAULT_LAYOUT_SEED_LABEL);
            const asInt = Number.parseInt(seedParam, 10);
            if (Number.isFinite(asInt)) return asInt >>> 0;
            return hashStringToSeed(seedParam);
        }

        const _layoutSeed = resolveLayoutSeed();
        const _baseCitySeed = hashStringToSeed('city-layout');
        const _baseTreeSeed = hashStringToSeed('tree-layout');

        function makeLayoutRng(labelSeed) {
            return makeRng((_layoutSeed ^ labelSeed) >>> 0);
        }

        if (DEBUG_STREAMING) {
            console.log(`üß™ Debug mode enabled | seed=${_layoutSeed} | tier=${State.qualityTier}`);
        }

        // ---- Far Silhouette Material (LOD2) ----
        // Opaque, solid, ultra-cheap box placeholder ‚Äî like "unloaded" game buildings.
        // Single shared MeshBasicMaterial: no PBR cost, fog handles atmospheric fade.
        const _silhouetteMaterial = new THREE.MeshBasicMaterial({
            color: 0x596274,   // cooler/darker massing for distant skyline readability
            fog: true          // fog provides natural distance fade, NOT transparency
        });

        function circleIntersectsAny(x, z, r) {
            // Keep-out around Eiffel
            const dxE = x - EIFFEL_XZ.x;
            const dzE = z - EIFFEL_XZ.y;
            const rrE = r + EIFFEL_KEEP_OUT_R;
            if ((dxE * dxE + dzE * dzE) < (rrE * rrE)) return true;

            for (const c of cityColliders) {
                const dx = x - c.x;
                const dz = z - c.z;
                const rr = r + c.r;
                if ((dx * dx + dz * dz) < (rr * rr)) return true;
            }
            return false;
        }

        function addCollider(x, z, r) {
            cityColliders.push({ x, z, r });
        }

        function createCity() {
            console.log('üèôÔ∏è Building city with streamed stages + starter density...');
            const rand = makeLayoutRng(_baseCitySeed);

            cityInstances.length = 0;
            cityLods.length = 0;
            cityZones.length = 0;
            cityColliders.length = 0;

            cityGroup = new THREE.Group();
            cityGroup.name = 'city';
            groups.city = cityGroup;

            const hasRealBuildings = loadedModels.buildings && loadedModels.buildings.length > 0;
            const quality = getQualitySettings();
            const bands = getStreamingBands('city');
            const baseCount = quality.buildingCount;

            const templates = [];
            if (hasRealBuildings) {
                for (let i = 0; i < loadedModels.buildings.length; i++) {
                    const gltf = loadedModels.buildings[i];
                    if (!gltf || !gltf.scene) continue;
                    const raw = gltf.scene.clone(true);
                    improveTextureFiltering(raw);

                    raw.traverse((child) => {
                        if (!child.isMesh) return;
                        child.castShadow = false;
                        child.receiveShadow = false;
                        if (child.material) child.material.envMapIntensity = 1.35;
                    });

                    const normalized = normalizeToBaseline(raw, { targetHeight: 165 });
                    templates.push({ hi: normalized.wrapper, size: normalized.size });
                }
            }

            const useFallback = templates.length === 0;
            const proxyBaseMat = MATERIALS.limestone.clone();

            function inSightCorridor(x, z, r) {
                if (Math.abs(x) < 90 + r && z > -250 && z < 250) return true;
                if (Math.abs(x) < 70 + r && z > -420 && z < -120) return true;
                return false;
            }

            function canPlace(x, z, r) {
                if (inSightCorridor(x, z, r)) return false;
                return !circleIntersectsAny(x, z, r);
            }

            function makeFallbackHi(size, randFn) {
                const w = Math.max(20, size?.x || (26 + randFn() * 30));
                const h = Math.max(70, size?.y || (80 + randFn() * 170));
                const d = Math.max(20, size?.z || (20 + randFn() * 26));
                const mat = proxyBaseMat.clone();
                mat.color.offsetHSL(0, 0, (randFn() - 0.5) * 0.1);
                const m = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), mat);
                m.position.y = h * 0.5;
                m.receiveShadow = true;
                return m;
            }

            function makeCityStream(template, scalar) {
                let hiNode;
                let finalSize;

                if (template) {
                    hiNode = template.hi.clone(true);
                    hiNode.scale.multiplyScalar(scalar);
                    hiNode.updateMatrixWorld(true);
                    const hiBox = getTightMeshBox(hiNode);
                    hiNode.position.y += -hiBox.min.y;
                    hiNode.updateMatrixWorld(true);
                    finalSize = getTightMeshBox(hiNode).getSize(new THREE.Vector3());
                } else {
                    hiNode = makeFallbackHi(null, rand);
                    finalSize = new THREE.Vector3(34 + rand() * 20, 110 + rand() * 120, 28 + rand() * 20);
                }

                const proxyMat = MATERIALS.limestone.clone();
                proxyMat.color.offsetHSL(0, 0, (rand() - 0.5) * 0.08);
                const proxyNode = makeProxyBuilding(finalSize, proxyMat);

                const silW = Math.max(12, finalSize.x * 0.95);
                const silH = Math.max(24, finalSize.y * 0.95);
                const silD = Math.max(12, finalSize.z * 0.95);
                const silhouetteNode = new THREE.Mesh(new THREE.BoxGeometry(silW, silH, silD), _silhouetteMaterial);
                silhouetteNode.position.y = silH * 0.5;
                silhouetteNode.castShadow = false;
                silhouetteNode.receiveShadow = false;

                return buildStreamObject('city', hiNode, proxyNode, silhouetteNode, rand);
            }

            function footprintRadiusFromTemplate(template, scalar) {
                if (!template) {
                    const baseR = State.isMobile ? 32 : 40;
                    return baseR * scalar + rand() * 10;
                }
                const footprint = Math.max(template.size.x, template.size.z) * 0.55;
                return footprint * scalar;
            }

            function placeAt(x, z, scalar, baseRot, template) {
                const r = footprintRadiusFromTemplate(template, scalar);
                if (!canPlace(x, z, r)) return false;

                const stream = makeCityStream(template, scalar);
                stream.position.set(x, 0, z);
                stream.rotation.y = baseRot + (rand() - 0.5) * 0.16;
                stream.userData.colliderR = r;

                cityGroup.add(stream);
                cityInstances.push(stream);
                cityLods.push(stream);
                addCollider(x, z, r);
                return true;
            }

            // Grid base
            const originX = 0;
            const originZ = -650;
            const blocksX = State.isMobile ? 4 : 6;
            const blocksZ = State.isMobile ? 3 : 5;
            const blockSize = State.isMobile ? 180 : 210;
            const street = State.isMobile ? 70 : 85;
            const halfSpanX = ((blocksX - 1) * (blockSize + street)) * 0.5;
            const halfSpanZ = ((blocksZ - 1) * (blockSize + street)) * 0.5;
            const perBlock = Math.ceil(baseCount / (blocksX * blocksZ));

            let placed = 0;
            for (let bz = 0; bz < blocksZ && placed < baseCount; bz++) {
                for (let bx = 0; bx < blocksX && placed < baseCount; bx++) {
                    const cx = originX + (bx * (blockSize + street) - halfSpanX);
                    const cz = originZ + (bz * (blockSize + street) - halfSpanZ);
                    const half = blockSize * 0.5;

                    for (let k = 0; k < perBlock && placed < baseCount; k++) {
                        const edge = Math.floor(rand() * 4);
                        const scalar = 0.88 + rand() * 0.36;
                        const chosenTemplate = useFallback ? null : templates[Math.floor(rand() * templates.length)];

                        let x;
                        let z;
                        let rotY;
                        const jitter = (rand() - 0.5) * 22;

                        if (edge === 0) {
                            x = cx + (rand() * blockSize - half);
                            z = cz - half - (street * 0.35) + jitter;
                            rotY = Math.PI;
                        } else if (edge === 1) {
                            x = cx + (rand() * blockSize - half);
                            z = cz + half + (street * 0.35) + jitter;
                            rotY = 0;
                        } else if (edge === 2) {
                            x = cx - half - (street * 0.35) + jitter;
                            z = cz + (rand() * blockSize - half);
                            rotY = Math.PI * 0.5;
                        } else {
                            x = cx + half + (street * 0.35) + jitter;
                            z = cz + (rand() * blockSize - half);
                            rotY = -Math.PI * 0.5;
                        }

                        let ok = false;
                        for (let attempt = 0; attempt < 24; attempt++) {
                            const ax = x + (rand() - 0.5) * 30;
                            const az = z + (rand() - 0.5) * 30;
                            const r = footprintRadiusFromTemplate(chosenTemplate, scalar);
                            if (canPlace(ax, az, r)) {
                                x = ax;
                                z = az;
                                ok = true;
                                break;
                            }
                        }
                        if (!ok) continue;
                        if (!placeAt(x, z, scalar, rotY, chosenTemplate)) continue;
                        placed++;
                    }
                }
            }

            // Left expansion (fills side volume from camera sweeps)
            if (!useFallback && !State.isMobile) {
                const leftExtra = State.qualityTier === 'HIGH' ? 20 : State.qualityTier === 'MEDIUM' ? 12 : 5;
                const leftOriginX = -halfSpanX - (blockSize + street) * 0.9;
                const leftSpanZ = halfSpanZ * 2.2;

                for (let k = 0; k < leftExtra * 3; k++) {
                    const t2 = templates[Math.floor(rand() * templates.length)];
                    const scalar = 0.84 + rand() * 0.34;
                    const stripWidth = blockSize * 1.45;
                    let x = leftOriginX - rand() * stripWidth;
                    let z = originZ + (rand() - 0.3) * leftSpanZ;

                    let ok = false;
                    for (let attempt = 0; attempt < 20; attempt++) {
                        const ax = x + (rand() - 0.5) * 38;
                        const az = z + (rand() - 0.5) * 38;
                        const r = footprintRadiusFromTemplate(t2, scalar);
                        if (canPlace(ax, az, r)) {
                            x = ax;
                            z = az;
                            ok = true;
                            break;
                        }
                    }
                    if (!ok) continue;
                    if (placeAt(x, z, scalar, (rand() - 0.5) * Math.PI * 0.5, t2)) placed++;
                }
            }

            // Starter clusters around hero/Eiffel for immediate city density.
            const starterTarget = DENSITY_TUNING.cityStarterClusters[State.qualityTier] || 16;
            const starterCenters = [
                new THREE.Vector2(-300, -470),
                new THREE.Vector2(300, -470),
                new THREE.Vector2(-340, -620),
                new THREE.Vector2(340, -620),
                new THREE.Vector2(-250, -780),
                new THREE.Vector2(250, -780),
                new THREE.Vector2(-120, -860),
                new THREE.Vector2(120, -860),
                new THREE.Vector2(0, -920)
            ];

            let starterPlaced = 0;
            let starterAttempts = 0;
            while (starterPlaced < starterTarget && starterAttempts < starterTarget * 30) {
                starterAttempts++;
                const center = starterCenters[Math.floor(rand() * starterCenters.length)];
                const scalar = 0.82 + rand() * 0.34;
                const t2 = useFallback ? null : templates[Math.floor(rand() * templates.length)];
                const jitterX = (rand() - 0.5) * 140;
                const jitterZ = (rand() - 0.5) * 120;
                const x = center.x + jitterX;
                const z = center.y + jitterZ;
                const rotY = (rand() - 0.5) * Math.PI * 0.9;
                if (!placeAt(x, z, scalar, rotY, t2)) continue;
                starterPlaced++;
                placed++;
            }

            pushApart(cityInstances, State.isMobile ? 92 : 126, 4);

            ensureWorldGroups();
            groups.bgRoot.add(cityGroup);

            const zones = buildStreamZonesFromItems(cityLods, bands.zoneSize, 105);
            cityZones.length = 0;
            for (let i = 0; i < zones.length; i++) cityZones.push(zones[i]);

            cityPlacedCount = placed;
            console.log(`‚úÖ City built: ${cityPlacedCount} buildings, ${cityLods.length} streamed objects in ${cityZones.length} zones`);
            if (DEBUG_STREAMING) {
                console.log(`üß™ City debug | starterPlaced=${starterPlaced} | baseCount=${baseCount}`);
            }
        }

        function createMountains() {
            ensureWorldGroups();
            if (!groups.bgRoot) return null;

            if (groups.mountains && groups.mountains.parent) {
                groups.mountains.parent.remove(groups.mountains);
            }

            const mountainGroup = new THREE.Group();
            mountainGroup.name = 'mountains';

            const anchors = [
                { x: -1400, z: -1500, targetHeight: 720, scale: 1.18, rotY: 0.12 },
                { x: -520, z: -1760, targetHeight: 640, scale: 1.0, rotY: -0.24 },
                { x: 420, z: -1820, targetHeight: 680, scale: 1.06, rotY: 0.18 },
                { x: 1300, z: -1520, targetHeight: 700, scale: 1.14, rotY: -0.08 }
            ];

            if (loadedModels.mountains && loadedModels.mountains.length > 0) {
                for (let i = 0; i < anchors.length; i++) {
                    const anchor = anchors[i];
                    const src = loadedModels.mountains[i % loadedModels.mountains.length];
                    if (!src?.scene) continue;

                    const clone = src.scene.clone(true);
                    improveTextureFiltering(clone);
                    clone.traverse((child) => {
                        if (!child.isMesh) return;
                        child.castShadow = false;
                        child.receiveShadow = true;
                        const mats = Array.isArray(child.material) ? child.material : [child.material];
                        mats.forEach((m) => {
                            if (!m) return;
                            if (m.metalness !== undefined) m.metalness = 0.02;
                            if (m.roughness !== undefined) m.roughness = Math.max(m.roughness, 0.82);
                            m.fog = true;
                            m.needsUpdate = true;
                        });
                    });

                    const normalized = normalizeToBaseline(clone, {
                        targetHeight: anchor.targetHeight,
                        clampMin: 0.06,
                        clampMax: 42,
                        minHeightBoost: 1
                    });
                    normalized.wrapper.scale.multiplyScalar(anchor.scale);
                    const y = getGroundY(anchor.x, anchor.z, 0);
                    normalized.wrapper.position.set(anchor.x, y - 8, anchor.z);
                    normalized.wrapper.rotation.y = anchor.rotY;
                    mountainGroup.add(normalized.wrapper);
                }
            } else {
                for (let i = 0; i < anchors.length; i++) {
                    const anchor = anchors[i];
                    const mesh = new THREE.Mesh(
                        new THREE.ConeGeometry(340, anchor.targetHeight, 10),
                        MATERIALS.riverBed.clone()
                    );
                    mesh.position.set(anchor.x, getGroundY(anchor.x, anchor.z, 0) + anchor.targetHeight * 0.42, anchor.z);
                    mesh.rotation.y = anchor.rotY;
                    mesh.scale.setScalar(anchor.scale);
                    mountainGroup.add(mesh);
                }
            }

            groups.mountains = mountainGroup;
            groups.bgRoot.add(mountainGroup);
            return mountainGroup;
        }



        // Distance-based culling (vanish logic) - uses quality settings
        const CULL = {
            checkIntervalMs: 150 // Faster checks for smoother transitions
        };
        let lastCullTime = 0;

        function improveTextureFiltering(root) {
            const maxAniso = renderer?.capabilities?.getMaxAnisotropy?.() || 8;

            root.traverse((o) => {
                if (!o.isMesh || !o.material) return;

                const mats = Array.isArray(o.material) ? o.material : [o.material];
                mats.forEach((m) => {
                    ['map', 'normalMap', 'roughnessMap', 'metalnessMap', 'aoMap', 'emissiveMap'].forEach((k) => {
                        const tex = m[k];
                        if (!tex) return;
                        tex.anisotropy = Math.min(8, maxAniso);
                        tex.minFilter = THREE.LinearMipmapLinearFilter;
                        tex.magFilter = THREE.LinearFilter;
                        tex.needsUpdate = true;
                    });
                    m.needsUpdate = true;
                });
            });
        }


        function getStreamingBands(kind) {
            const table = kind === 'tree' ? STREAMING_BANDS.tree : STREAMING_BANDS.city;
            return table[State.qualityTier] || table.MEDIUM;
        }

        function cloneMaterialsOnObject(root) {
            root.traverse((o) => {
                if (!o.isMesh || !o.material) return;
                if (Array.isArray(o.material)) {
                    o.material = o.material.map((m) => (m ? m.clone() : m));
                } else {
                    o.material = o.material.clone();
                }
            });
        }

        function collectObjectMaterials(root) {
            const mats = [];
            const seen = new Set();
            root.traverse((o) => {
                if (!o.isMesh || !o.material) return;
                const arr = Array.isArray(o.material) ? o.material : [o.material];
                for (let i = 0; i < arr.length; i++) {
                    const m = arr[i];
                    if (!m || seen.has(m)) continue;
                    if (m.opacity === undefined) continue;
                    seen.add(m);
                    if (m.userData._streamBaseOpacity === undefined) {
                        m.userData._streamBaseOpacity = m.opacity;
                        m.userData._streamBaseTransparent = !!m.transparent;
                        m.userData._streamBaseDepthWrite = m.depthWrite !== undefined ? m.depthWrite : true;
                    }
                    mats.push(m);
                }
            });
            return mats;
        }

        function setMaterialsAlpha(materials, alpha) {
            const a = THREE.MathUtils.clamp(alpha, 0, 1);
            for (let i = 0; i < materials.length; i++) {
                const m = materials[i];
                const baseOpacity = m.userData._streamBaseOpacity ?? 1;
                const targetOpacity = baseOpacity * a;
                const useBlend = targetOpacity < (baseOpacity - 0.01);
                const nextTransparent = useBlend ? true : !!m.userData._streamBaseTransparent;
                const nextDepthWrite = useBlend ? false : (m.userData._streamBaseDepthWrite ?? true);
                if (m.transparent !== nextTransparent || m.depthWrite !== nextDepthWrite) {
                    m.needsUpdate = true;
                }
                m.opacity = targetOpacity;
                m.transparent = nextTransparent;
                m.depthWrite = nextDepthWrite;
            }
        }

        function buildStreamObject(kind, hiNode, proxyNode, silhouetteNode, rand) {
            cloneMaterialsOnObject(hiNode);
            cloneMaterialsOnObject(proxyNode);

            const stream = new THREE.Group();
            stream.name = `${kind}Stream`;

            stream.add(silhouetteNode);
            stream.add(proxyNode);
            stream.add(hiNode);

            silhouetteNode.visible = false;
            proxyNode.visible = false;
            hiNode.visible = false;

            const bands = getStreamingBands(kind);
            const fadeMs = bands.fadeMsMin + rand() * (bands.fadeMsMax - bands.fadeMsMin);

            stream.userData.stream = {
                kind,
                stage: 0,
                transition: null,
                bands,
                proxy: proxyNode,
                hi: hiNode,
                silhouette: silhouetteNode,
                proxyMats: collectObjectMaterials(proxyNode),
                hiMats: collectObjectMaterials(hiNode),
                fadeMs,
                visibleLastFrame: false
            };

            stream.frustumCulled = true;
            return stream;
        }

        function applyStageImmediate(stream, stage) {
            const d = stream.userData.stream;
            d.stage = stage;
            d.transition = null;
            streamTransitions.delete(stream);

            if (stage <= 0) {
                stream.visible = false;
                d.silhouette.visible = false;
                d.proxy.visible = false;
                d.hi.visible = false;
                setMaterialsAlpha(d.proxyMats, 0);
                setMaterialsAlpha(d.hiMats, 0);
                return;
            }

            stream.visible = true;
            if (stage === 1) {
                d.silhouette.visible = true;
                d.silhouette.scale.setScalar(1);
                d.proxy.visible = false;
                d.hi.visible = false;
                setMaterialsAlpha(d.proxyMats, 0);
                setMaterialsAlpha(d.hiMats, 0);
                return;
            }

            if (stage === 2) {
                d.silhouette.visible = false;
                d.proxy.visible = true;
                d.hi.visible = false;
                setMaterialsAlpha(d.proxyMats, 1);
                setMaterialsAlpha(d.hiMats, 0);
                return;
            }

            d.silhouette.visible = false;
            d.proxy.visible = false;
            d.hi.visible = true;
            setMaterialsAlpha(d.proxyMats, 0);
            setMaterialsAlpha(d.hiMats, 1);
        }

        function beginStageTransition(stream, nextStage, nowMs) {
            const d = stream.userData.stream;
            d.transition = {
                toStage: nextStage,
                startMs: nowMs,
                durationMs: d.fadeMs
            };
            streamTransitions.add(stream);
            stream.visible = true;

            if (nextStage === 1) {
                d.silhouette.visible = true;
                d.silhouette.scale.setScalar(0.88);
                d.proxy.visible = false;
                d.hi.visible = false;
                setMaterialsAlpha(d.proxyMats, 0);
                setMaterialsAlpha(d.hiMats, 0);
                return;
            }

            if (nextStage === 2) {
                d.silhouette.visible = true;
                d.proxy.visible = true;
                d.hi.visible = false;
                setMaterialsAlpha(d.proxyMats, 0);
                setMaterialsAlpha(d.hiMats, 0);
                return;
            }

            d.silhouette.visible = false;
            d.proxy.visible = true;
            d.hi.visible = true;
            setMaterialsAlpha(d.proxyMats, 1);
            setMaterialsAlpha(d.hiMats, 0);
        }

        function getTargetStageForDistance(d, dist) {
            const h = d.bands.hysteresis || 0.10;
            const far = d.bands.farStart * ((d.stage > 0 || d.transition) ? (1 + h) : 1);
            if (dist > far) return 0;

            const mid = d.bands.midStart * ((d.stage > 1 || (d.transition && d.transition.toStage > 1)) ? (1 + h * 0.55) : 1);
            if (dist > mid) return 1;

            const near = d.bands.nearStart * ((d.stage > 2 || (d.transition && d.transition.toStage > 2)) ? (1 + h * 0.35) : 1);
            if (dist > near) return 2;
            return 3;
        }

        function requestStreamStage(stream, targetStage, nowMs, dist = Infinity) {
            const d = stream.userData.stream;
            const clampedTarget = THREE.MathUtils.clamp(targetStage, 0, 3);

            // Downgrades are instant to keep frame cost predictable.
            if (clampedTarget < d.stage) {
                applyStageImmediate(stream, clampedTarget);
                return;
            }

            if (d.transition) {
                if (clampedTarget <= d.transition.toStage) {
                    if (clampedTarget === 3 && dist <= d.bands.nearFull && d.transition.toStage === 3) {
                        d.transition.startMs = Math.min(d.transition.startMs, nowMs - d.transition.durationMs * 0.8);
                    }
                    return;
                }
                return;
            }

            if (clampedTarget === d.stage) return;
            let nextStage = Math.min(clampedTarget, d.stage + 1);
            if (clampedTarget === 3 && dist <= d.bands.nearFull) {
                nextStage = Math.min(3, d.stage + 2);
            }
            beginStageTransition(stream, nextStage, nowMs);
        }

        function updateStreamTransitions(nowMs) {
            if (streamTransitions.size === 0) return;

            const finished = [];
            streamTransitions.forEach((stream) => {
                const d = stream.userData.stream;
                const tr = d.transition;
                if (!tr) {
                    finished.push(stream);
                    return;
                }

                const t = THREE.MathUtils.clamp((nowMs - tr.startMs) / Math.max(1, tr.durationMs), 0, 1);

                if (tr.toStage === 1) {
                    d.silhouette.scale.setScalar(0.88 + 0.12 * t);
                } else if (tr.toStage === 2) {
                    setMaterialsAlpha(d.proxyMats, t);
                    if (t > 0.75) d.silhouette.visible = false;
                } else if (tr.toStage === 3) {
                    setMaterialsAlpha(d.hiMats, t);
                    setMaterialsAlpha(d.proxyMats, Math.max(0, 1 - t));
                }

                if (t >= 1) {
                    applyStageImmediate(stream, tr.toStage);
                    finished.push(stream);
                }
            });

            for (let i = 0; i < finished.length; i++) {
                streamTransitions.delete(finished[i]);
            }
        }

        function updateStreamZones(zones, camera, nowMs, visibilityGate = null) {
            if (!zones || zones.length === 0) return;
            const camX = camera.position.x;
            const camZ = camera.position.z;
            const preloadMode = !!(visibilityGate && visibilityGate.enabled && visibilityGate.preloadMode);
            const offscreenPreloadBoost = Math.max(1, visibilityGate?.offscreenPreloadBoost || 1);
            const offscreenMaxStage = visibilityGate?.offscreenMaxStage || 2;

            for (let z = 0; z < zones.length; z++) {
                const zone = zones[z];
                _sphere.set(zone.center, zone.radius + zone.maxFarStart * 0.3);
                const zoneVisible = _frustum.intersectsSphere(_sphere);

                if (!zoneVisible && !preloadMode) {
                    for (let i = 0; i < zone.items.length; i++) {
                        zone.items[i].visible = false;
                    }
                    continue;
                }

                for (let i = 0; i < zone.items.length; i++) {
                    const stream = zone.items[i];
                    const d = stream.userData.stream;
                    const dx = stream.position.x - camX;
                    const dz = stream.position.z - camZ;
                    const dist = Math.sqrt(dx * dx + dz * dz);
                    let targetStage = getTargetStageForDistance(d, dist);

                    if (visibilityGate && visibilityGate.enabled) {
                        const distanceScale = visibilityGate.distanceScale || 1;
                        const maxDist = d.bands.farStart * distanceScale;
                        if (dist > maxDist) {
                            targetStage = 0;
                        } else if (targetStage > visibilityGate.maxStage) {
                            targetStage = visibilityGate.maxStage;
                        }
                    }

                    // Allow off-frustum preload while cloud mask is active so reveal is ready.
                    if (!zoneVisible && preloadMode) {
                        const preloadDist = d.bands.farStart * offscreenPreloadBoost;
                        if (dist <= preloadDist) {
                            targetStage = Math.max(1, targetStage);
                            targetStage = Math.min(targetStage, offscreenMaxStage);
                        } else {
                            targetStage = 0;
                        }
                    }

                    if (targetStage === 0 && d.stage === 0 && !d.transition) {
                        stream.visible = false;
                        continue;
                    }
                    stream.visible = true;
                    requestStreamStage(stream, targetStage, nowMs, dist);
                    if (!zoneVisible) stream.visible = false;
                }
            }
        }

        const STREAM_STAGE_READINESS = [0, 0.34, 0.72, 1];
        function scoreStreamReadiness(streamData, nowMs) {
            const stage = THREE.MathUtils.clamp(streamData?.stage ?? 0, 0, 3);
            let score = STREAM_STAGE_READINESS[stage] || 0;

            if (!streamData?.transition) return score;

            const toStage = THREE.MathUtils.clamp(streamData.transition.toStage ?? stage, 0, 3);
            const duration = Math.max(1, streamData.transition.durationMs || 1);
            const t = THREE.MathUtils.clamp((nowMs - streamData.transition.startMs) / duration, 0, 1);
            const fromScore = STREAM_STAGE_READINESS[stage] || 0;
            const toScore = STREAM_STAGE_READINESS[toStage] || fromScore;
            score = THREE.MathUtils.lerp(fromScore, toScore, t);
            return score;
        }

        function computeStreamingReadiness(nowMs) {
            if (!camera) return 0;

            const sampling = CLOUD_TRANSITION_CONFIG.readinessSampling;
            const minDist = sampling.minDistance;
            const maxDist = sampling.maxDistance;
            const minDot = sampling.minForwardDot;
            const distRange = Math.max(1, maxDist - minDist);

            camera.getWorldDirection(_readinessForward);

            let weightedScore = 0;
            let weightedSamples = 0;

            function sampleStreams(streams, baseWeight) {
                for (let i = 0; i < streams.length; i++) {
                    const stream = streams[i];
                    const streamData = stream?.userData?.stream;
                    if (!streamData) continue;

                    const dx = stream.position.x - camera.position.x;
                    const dy = stream.position.y - camera.position.y;
                    const dz = stream.position.z - camera.position.z;
                    const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
                    if (dist < minDist || dist > maxDist) continue;

                    _readinessDir.set(dx, dy, dz).divideScalar(Math.max(dist, 0.0001));
                    const dot = _readinessDir.dot(_readinessForward);
                    if (dot < minDot) continue;

                    const distWeight = 1 - THREE.MathUtils.clamp((dist - minDist) / distRange, 0, 1);
                    const frontWeight = THREE.MathUtils.clamp((dot - minDot) / Math.max(0.0001, 1 - minDot), 0, 1);
                    const sampleWeight = baseWeight * (0.28 + distWeight * 0.72) * (0.3 + frontWeight * 0.7);
                    const readiness = scoreStreamReadiness(streamData, nowMs);

                    weightedScore += readiness * sampleWeight;
                    weightedSamples += sampleWeight;
                }
            }

            sampleStreams(cityLods, 1.0);
            sampleStreams(treeLods, sampling.treeWeight || 0.4);

            if (weightedSamples < (sampling.minWeightedSamples || 8)) return 0;
            return THREE.MathUtils.clamp(weightedScore / weightedSamples, 0, 1);
        }

        function prewarmStreamingAtHome() {
            if (!camera) return;
            const nowMs = performance.now();
            const preloadGate = {
                enabled: true,
                distanceScale: 0.72,
                maxStage: 2,
                treeProxyScale: 0.72,
                preloadMode: true,
                offscreenPreloadBoost: 2.25,
                offscreenMaxStage: 2
            };
            if (DEBUG_CLOUD_PRELOAD) console.log('üå´Ô∏è [prewarm-home] running offscreen preload pass');

            _projMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
            _frustum.setFromProjectionMatrix(_projMatrix);
            if (cityZones.length > 0) updateStreamZones(cityZones, camera, nowMs, preloadGate);
            if (treeZones.length > 0) updateStreamZones(treeZones, camera, nowMs, preloadGate);
            updateStreamTransitions(nowMs + 340);
            State.streamingReadiness = computeStreamingReadiness(nowMs + 340);
        }

        function applyCloudCurtainState(mode) {
            if (!cloudManager) return;
            if (mode === previousCloudCurtainState) return;

            previousCloudCurtainState = mode;
            if (DEBUG_CLOUD_PRELOAD) console.log(`üå´Ô∏è [curtain] ${mode}`);

            if (mode === 'HOME_IDLE') {
                cloudManager.setBaseline();
            } else if (mode === 'TRANSITION_MASK') {
                cloudManager.setMaskStrong();
            } else if (mode === 'TRANSITION_REVEAL') {
                cloudManager.fadeOut();
            } else {
                cloudManager.setOff();
            }
        }

        function shouldRunSectionTransition(fromSection, toSection) {
            if (fromSection === toSection) return false;
            if (fromSection === 0 || toSection === 0) return true;
            return SCENE_FLOW_CONFIG.transitionSections.has(toSection);
        }

        function beginSceneTransition(toSection, progressVelocity, nowMs) {
            sceneFlow.transition.active = true;
            sceneFlow.transition.fromSection = sceneFlow.lastSection;
            sceneFlow.transition.toSection = toSection;
            sceneFlow.transition.startMs = nowMs;
            sceneFlow.transition.durationMs =
                (toSection === 0 || sceneFlow.lastSection === 0)
                    ? SCENE_FLOW_CONFIG.homeTransitionMs
                    : SCENE_FLOW_CONFIG.sectionTransitionMs;
            sceneFlow.transition.deadlineMs = nowMs + BG_REVEAL_TIMEOUT_MS;
            sceneFlow.transition.direction = progressVelocity >= 0 ? 1 : -1;
            sceneFlow.state = SceneState.TRANSITION;

            cloudCurtainState = 'TRANSITION_MASK';
            bgRevealLocked = true;
            setBackgroundVisibility(false);
            if (DEBUG_CLOUD_PRELOAD) {
                console.log(`üé¨ [transition] ${sceneFlow.transition.fromSection} -> ${toSection}`);
            }
        }

        function updateSceneStateMachine(nowMs, progressVelocity = 0) {
            if (!groups.bgRoot) return;

            if (!sceneFlow.bootDeadlineMs) {
                sceneFlow.bootDeadlineMs = nowMs + SCENE_FLOW_CONFIG.bootTimeoutMs;
            }

            if (!bgGateState.ready && nowMs >= sceneFlow.bootDeadlineMs) {
                bgGateState.timedOut = true;
            }

            const currentSection = State.section;

            if (sceneFlow.state === SceneState.BOOT_LOADING) {
                cloudCurtainState = 'HOME_IDLE';
                bgRevealLocked = true;
                setBackgroundVisibility(false);

                if (bgGateState.ready || bgGateState.timedOut) {
                    sceneFlow.state = SceneState.HOME_READY;
                    sceneFlow.lastSection = 0;
                }
                return;
            }

            if (!sceneFlow.transition.active && shouldRunSectionTransition(sceneFlow.lastSection, currentSection)) {
                beginSceneTransition(currentSection, progressVelocity, nowMs);
            }

            if (sceneFlow.transition.active) {
                const tr = sceneFlow.transition;
                const tNorm = THREE.MathUtils.clamp(
                    (nowMs - tr.startMs) / Math.max(1, tr.durationMs),
                    0,
                    1
                );
                const readyForReveal =
                    (bgGateState.ready && State.streamingReadiness >= BG_READY_THRESHOLD) ||
                    bgGateState.timedOut ||
                    nowMs >= tr.deadlineMs;

                if (tr.toSection === 0) {
                    cloudCurtainState = (tNorm < SCENE_FLOW_CONFIG.homeReturnMaskUntil) ? 'TRANSITION_MASK' : 'HOME_IDLE';
                    bgRevealLocked = true;
                    setBackgroundVisibility(false);

                    if (tNorm >= 1) {
                        tr.active = false;
                        sceneFlow.state = SceneState.HOME_READY;
                        sceneFlow.lastSection = 0;
                    }
                    return;
                }

                if (!readyForReveal || tNorm < SCENE_FLOW_CONFIG.revealAt) {
                    cloudCurtainState = 'TRANSITION_MASK';
                    bgRevealLocked = true;
                    setBackgroundVisibility(false);
                } else {
                    cloudCurtainState = 'TRANSITION_REVEAL';
                    bgRevealLocked = false;
                    setBackgroundVisibility(true);
                }

                if (tNorm >= 1 && readyForReveal) {
                    tr.active = false;
                    sceneFlow.state = SceneState.SECTION_READY;
                    cloudCurtainState = 'OFF';
                    bgRevealLocked = false;
                    setBackgroundVisibility(true);
                }
                sceneFlow.lastSection = currentSection;
                return;
            }

            if (currentSection === 0 || State.progress <= BG_HIDE_PROGRESS + 0.003) {
                sceneFlow.state = SceneState.HOME_READY;
                sceneFlow.lastSection = 0;
                cloudCurtainState = 'HOME_IDLE';
                bgRevealLocked = true;
                setBackgroundVisibility(false);
                return;
            }

            sceneFlow.state = SceneState.SECTION_READY;
            sceneFlow.lastSection = currentSection;
            cloudCurtainState = 'OFF';
            const canReveal =
                (bgGateState.ready && State.streamingReadiness >= BG_READY_THRESHOLD) ||
                bgGateState.timedOut;
            bgRevealLocked = !canReveal;
            setBackgroundVisibility(canReveal);
        }

        async function compileBackgroundAssets() {
            if (!renderer || !scene || !camera || !groups.bgRoot) return;
            if (compileAllPromise) {
                await compileAllPromise;
                return;
            }

            compileAllPromise = (async () => {
                const previousVisible = groups.bgRoot.visible;
                groups.bgRoot.visible = true;
                try {
                    if (typeof renderer.compileAsync === 'function') {
                        await renderer.compileAsync(scene, camera);
                    } else if (typeof renderer.compile === 'function') {
                        renderer.compile(scene, camera);
                    }
                    if (DEBUG_CLOUD_PRELOAD) console.log('üõ†Ô∏è [compile] background compile complete');
                } catch (error) {
                    console.warn('‚ö†Ô∏è Background compile skipped:', error);
                } finally {
                    groups.bgRoot.visible = previousVisible;
                }
            })();

            await compileAllPromise;
            bgGateState.compiled = true;
            bgGateState.ready = !!(bgGateState.assetsLoaded && bgGateState.compiled);
            if (bgGateState.ready) bgGateState.timedOut = false;
        }

        function buildStreamZonesFromItems(items, zoneSize, yCenter = 80) {
            const zones = [];
            const zoneMap = new Map();
            for (let i = 0; i < items.length; i++) {
                const item = items[i];
                const kx = Math.floor(item.position.x / zoneSize);
                const kz = Math.floor(item.position.z / zoneSize);
                const key = `${kx},${kz}`;

                if (!zoneMap.has(key)) {
                    zoneMap.set(key, {
                        items: [],
                        center: new THREE.Vector3((kx + 0.5) * zoneSize, yCenter, (kz + 0.5) * zoneSize),
                        radius: zoneSize * 0.88,
                        maxFarStart: 0
                    });
                }
                const zone = zoneMap.get(key);
                zone.items.push(item);
                const farStart = item.userData?.stream?.bands?.farStart || 0;
                if (farStart > zone.maxFarStart) zone.maxFarStart = farStart;
            }
            zoneMap.forEach((z) => zones.push(z));
            return zones;
        }

        function updateCityCulling(nowMs) {
            if (!groups.city || !groups.city.visible) return;
        }

        function logStreamingDebug(context = 'runtime') {
            if (!DEBUG_STREAMING || !renderer) return;
            console.log(
                `üß™ Stream Debug [${context}] seed=${_layoutSeed} tier=${State.qualityTier} dpr=${renderer.getPixelRatio().toFixed(2)} buildings=${cityPlacedCount} trees=${treePlacedCount}`
            );
        }

        function enforceMeshCulling(root) {
            if (!root) return;
            root.traverse((obj) => {
                if (!obj.isMesh) return;
                if (obj.renderOrder >= 9000) return; // cloud curtain meshes intentionally uncullable
                obj.frustumCulled = true;
            });
        }


        function pushApart(objects, minDist = 70, iterations = 2) {
            // Uses XZ only (ground plane). Cheap and effective.
            for (let it = 0; it < iterations; it++) {
                for (let i = 0; i < objects.length; i++) {
                    for (let j = i + 1; j < objects.length; j++) {
                        const a = objects[i], b = objects[j];
                        if (!a || !b) continue;

                        const dx = a.position.x - b.position.x;
                        const dz = a.position.z - b.position.z;
                        const d2 = dx * dx + dz * dz;
                        const min2 = minDist * minDist;

                        if (d2 > 0.0001 && d2 < min2) {
                            const d = Math.sqrt(d2);
                            const push = (minDist - d) * 0.5;
                            const nx = dx / d, nz = dz / d;
                            a.position.x += nx * push; a.position.z += nz * push;
                            b.position.x -= nx * push; b.position.z -= nz * push;
                        }
                    }
                }
            }
        }


        // --- Content Injection (keep yours) ---
        function injectContent() {
            if (!siteContent) return;
            const heroP = document.querySelector('#panel-hero p');
            if (heroP) heroP.innerText = siteContent.hero?.subheadline || heroP.innerText;

            const stats = document.querySelectorAll('.stat-value');
            if (siteContent.proof?.stats?.length >= 3) {
                if (stats[0]) stats[0].innerText = siteContent.proof.stats[0].value;
                if (stats[1]) stats[1].innerText = siteContent.proof.stats[1].value;
                if (stats[2]) stats[2].innerText = siteContent.proof.stats[2].value;
            }

            const projPanel = document.querySelector('#panel-projects .project-list');
            if (projPanel && siteContent.openSource?.projects?.length) {
                projPanel.innerHTML = '';
                siteContent.openSource.projects.forEach(p => {
                    const item = document.createElement('div');
                    item.className = 'project-item';
                    item.innerHTML = `<div><div class="title">${p.title}</div><div class="desc">${(p.description || '').substring(0, 60)}...</div></div>`;
                    projPanel.appendChild(item);
                });
            }

            const contactBtn = document.querySelector('#panel-contact .cta-button');
            const contactLabel = document.querySelector('#panel-contact .cta-button span');
            if (siteContent.finalCTA?.calendlyUrl && contactBtn) {
                contactBtn.href = siteContent.finalCTA.calendlyUrl;
                if (contactLabel) contactLabel.innerText = "Book Introduction";
            }

            splitText();
        }

        // Eiffel Tower (use loaded model ONLY - no procedural fallback)
        function createRealisticEiffelTower() {
            eiffelTower = new THREE.Group();

            if (loadedModels.eiffelTower && loadedModels.eiffelTower.scene) {
                const model = loadedModels.eiffelTower.scene.clone(true);
                improveTextureFiltering(model);
                model.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = false;
                        child.receiveShadow = false;
                        if (child.material) {
                            child.material.envMapIntensity = 1.5;
                            // Prevent pitch-black on highly metallic surfaces
                            if (child.material.metalness !== undefined && child.material.metalness > 0.9) {
                                child.material.metalness = 0.85;
                            }
                            if (child.material.roughness !== undefined && child.material.roughness < 0.1) {
                                child.material.roughness = 0.15;
                            }
                        }
                    }
                });

                // ‚úÖ normalize the actual model
                const normalized = normalizeToBaseline(model, { targetHeight: 380 });
                eiffelTower.add(normalized.wrapper);
            } else {
                // No model loaded - skip Eiffel entirely
                console.warn('‚ö†Ô∏è Eiffel Tower model not loaded, skipping');
                return;
            }

            // Beacon
            const beacon = new THREE.Mesh(
                new THREE.SphereGeometry(3, 16, 16),
                new THREE.MeshBasicMaterial({ color: 0xffaa00 })
            );
            beacon.position.y = 310;
            eiffelTower.add(beacon);

            if (State.qualityTier === 'HIGH') {
                const spot = new THREE.SpotLight(0xffaa00, 4.2, 400, 0.3, 0.5, 1);
                spot.position.set(0, 305, 0);
                spot.target.position.set(0, 1000, 0);
                eiffelTower.add(spot);
                eiffelTower.userData.spot = spot;
            }

            eiffelTower.position.set(0, 0, -300);
            ensureWorldGroups();
            groups.heroRoot.add(eiffelTower);
            groups.eiffel = eiffelTower;
        }

        function createCloudLayers() {
            if (!scene || !camera) return null;

            if (cloudManager) {
                cloudManager.dispose();
                cloudManager = null;
            }

            cloudManager = new CloudManager({
                THREE,
                scene,
                camera,
                textureUrl: assetUrl('/3d-models/cloud.png'),
                qualityTier: State.qualityTier,
                config: CLOUD_TRANSITION_CONFIG
            });

            worldStreamingManager = new WorldStreamingManager(WORLD_STREAMING_RUNTIME_CONFIG);

            groups.clouds = cloudManager.root;
            previousCloudCurtainState = 'OFF';
            cloudCurtainState = 'HOME_IDLE';
            applyCloudCurtainState(cloudCurtainState);
            return groups.clouds;
        }



        // Data spheres (keep interactive; small count)
        const raycaster = new THREE.Raycaster();
        let hoveredObject = null;

        // REMOVED: Data spheres section - not using loaded models
        function createDataSection() {
            // Data spheres removed - only using loaded GLB models
            dataSpheres = new THREE.Group();
            dataSpheres.visible = false;
            groups.dataSpheres = dataSpheres;
            // No procedural generation - skip entirely
        }

        // REMOVED: Skills code blocks section - not using loaded models
        function createSkillsSection() {
            // Code blocks removed - only using loaded GLB models
            codeBlocks = new THREE.Group();
            codeBlocks.visible = false;
            groups.codeBlocks = codeBlocks;
            // No procedural generation - skip entirely
        }

        function createScooter() {
            scooter = new THREE.Group();
            scooter.visible = false;
            groups.scooter = scooter;

            if (loadedModels.scooter && loadedModels.scooter.scene) {
                const model = loadedModels.scooter.scene.clone(true);

                model.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = false;
                        child.receiveShadow = false;
                        if (child.material) child.material.envMapIntensity = 1.5;
                    }
                });

                const normalized = normalizeToBaseline(model, { targetHeight: 12 });
                scooter.add(normalized.wrapper);

                if (State.qualityTier !== 'LOW') {
                    const beam = new THREE.SpotLight(0xffffff, 2, 30, 0.5, 0.5);
                    beam.position.set(2, 8, 0);
                    beam.target.position.set(10, 0, 0);
                    scooter.add(beam);
                    scooter.add(beam.target);
                }
            } else {
                // No model loaded - skip scooter entirely
                console.warn('‚ö†Ô∏è Scooter model not loaded, skipping');
                return;
            }

            scooter.position.set(-150, 0, 100);
            scooter.rotation.y = Math.PI / 4;
            scooter.userData = { floatOffset: Math.random() * 10 };
            ensureWorldGroups();
            groups.heroRoot.add(scooter);
        }

        // REMOVED: Particles - not using loaded models
        function createParticles() {
            // Particles removed - only using loaded GLB models
            particles = new THREE.Group();
            particles.visible = false;
            groups.particles = particles;
            // No procedural generation - skip entirely
        }

        // Camera path points are centralized so safety tuning is deterministic.
        const CAMERA_PATH_POINTS = {
            desktop: {
                camera: [
                    [90, 152, 500],
                    [240, 146, 310],
                    [245, 142, 70],
                    [210, 148, -190],
                    [70, 154, -440],
                    [-140, 158, -680],
                    [-250, 148, -470],
                    [-230, 142, -180],
                    [-40, 146, 80],
                    [55, 150, 290],
                    [90, 152, 500]
                ],
                lookAt: [
                    [0, 120, -300],
                    [80, 116, -420],
                    [92, 110, -520],
                    [50, 112, -590],
                    [0, 114, -620],
                    [-70, 120, -700],
                    [-120, 112, -540],
                    [-85, 108, -360],
                    [-10, 110, -230],
                    [0, 116, -250],
                    [0, 120, -300]
                ]
            },
            mobile: {
                camera: [
                    [24, 142, 430],
                    [120, 136, 280],
                    [136, 132, 120],
                    [128, 136, -40],
                    [40, 142, -230],
                    [-52, 146, -380],
                    [-110, 138, -260],
                    [-80, 134, -120],
                    [-18, 136, 10],
                    [16, 140, 180],
                    [24, 142, 430]
                ],
                lookAt: [
                    [0, 104, -300],
                    [40, 100, -360],
                    [55, 98, -430],
                    [45, 98, -500],
                    [10, 102, -560],
                    [-35, 105, -590],
                    [-52, 100, -470],
                    [-28, 98, -360],
                    [-4, 100, -285],
                    [0, 102, -255],
                    [0, 104, -300]
                ]
            }
        };

        function makeCurve(points) {
            return new THREE.CatmullRomCurve3(points.map(([x, y, z]) => new THREE.Vector3(x, y, z)));
        }

        const desktopLookAtPath = makeCurve(CAMERA_PATH_POINTS.desktop.lookAt);
        desktopLookAtPath.closed = true;

        const desktopCameraPath = makeCurve(CAMERA_PATH_POINTS.desktop.camera);
        desktopCameraPath.closed = true;

        const mobileCameraPath = makeCurve(CAMERA_PATH_POINTS.mobile.camera);
        mobileCameraPath.closed = true;

        const mobileLookAtPath = makeCurve(CAMERA_PATH_POINTS.mobile.lookAt);
        mobileLookAtPath.closed = true;

        const getCameraPath = () => State.isMobile ? mobileCameraPath : desktopCameraPath;
        const getLookAtPath = () => State.isMobile ? mobileLookAtPath : desktopLookAtPath;

        function samplePathPoint(path, t) {
            const wrapped = ((t % 1) + 1) % 1;
            return path.getPointAt(wrapped);
        }

        function applyCameraCollisionSafety(pos) {
            if (!pos) return pos;
            const safeDistance = CAMERA_PATH_TUNING.CAMERA_SAFE_DISTANCE;
            const maxPush = CAMERA_PATH_TUNING.maxCollisionPush;
            const blend = CAMERA_PATH_TUNING.collisionBlend;

            _cameraSafeTarget.copy(pos);
            let corrected = false;

            for (let pass = 0; pass < 2; pass++) {
                for (let i = 0; i < cityColliders.length; i++) {
                    const c = cityColliders[i];
                    const dx = _cameraSafeTarget.x - c.x;
                    const dz = _cameraSafeTarget.z - c.z;
                    const minR = c.r + safeDistance;
                    const d2 = dx * dx + dz * dz;
                    if (d2 >= minR * minR) continue;

                    corrected = true;
                    const d = Math.max(0.001, Math.sqrt(d2));
                    _cameraSafeDirection.set(dx / d, dz / d);
                    const push = Math.min((minR - d) + 1.2, maxPush);
                    _cameraSafeTarget.x += _cameraSafeDirection.x * push;
                    _cameraSafeTarget.z += _cameraSafeDirection.y * push;
                }
            }

            const dxE = _cameraSafeTarget.x - EIFFEL_XZ.x;
            const dzE = _cameraSafeTarget.z - EIFFEL_XZ.y;
            const keepOut = EIFFEL_KEEP_OUT_R + safeDistance * 0.45;
            const d2E = dxE * dxE + dzE * dzE;
            if (d2E < keepOut * keepOut) {
                corrected = true;
                const dE = Math.max(0.001, Math.sqrt(d2E));
                _cameraSafeDirection.set(dxE / dE, dzE / dE);
                const pushE = Math.min((keepOut - dE) + 1, maxPush);
                _cameraSafeTarget.x += _cameraSafeDirection.x * pushE;
                _cameraSafeTarget.z += _cameraSafeDirection.y * pushE;
            }

            const groundY = getGroundY(_cameraSafeTarget.x, _cameraSafeTarget.z, SCENE_CONFIG.cameraMinY);
            _cameraSafeTarget.y = Math.max(
                _cameraSafeTarget.y,
                groundY + CAMERA_PATH_TUNING.cameraGroundClearance,
                SCENE_CONFIG.cameraMinY
            );

            pos.lerp(_cameraSafeTarget, corrected ? blend : 1);
            return pos;
        }

        // Visibility by section - ONLY loaded models + terrain
        function applySectionVisibility(section) {
            const setV = (key, v) => { if (groups[key]) groups[key].visible = v; };

            // Only show loaded GLB models
            setV('heroRoot', true);  // Hero anchor should always stay readable.
            setV('city', true);      // Buildings from loaded models
            setV('trees', true);     // Trees (GLB LOD + instanced proxies)
            setV('mountains', true); // Background mountain strip
            setV('eiffel', true);    // Eiffel from loaded model
            setV('scooter', section >= 1 && section <= 2); // Scooter from loaded model

            // NEW: Terrain always visible
            setV('terrain', true);   // Grass, river, land

            // Disabled: procedural elements (particles, dataSpheres, codeBlocks, serverRacks)
            setV('particles', false);
            setV('dataSpheres', false);
            setV('codeBlocks', false);
            setV('serverRacks', false);
        }

        function updatePanels() {
            const s = State.progress;
            const ranges = [[0, 0.09], [0.09, 0.18], [0.18, 0.28], [0.28, 0.38], [0.38, 0.48], [0.48, 0.58], [0.58, 0.68], [0.68, 0.78], [0.78, 0.88], [0.88, 1.0]];

            if (!panels.hero) return;

            panels.hero.classList.toggle('active', s >= ranges[0][0] && s < ranges[0][1]);
            panels.intro.classList.toggle('active', s >= ranges[1][0] && s < ranges[1][1]);
            panels.journey.classList.toggle('active', s >= ranges[2][0] && s < ranges[2][1]);
            panels.architecture.classList.toggle('active', s >= ranges[3][0] && s < ranges[3][1]);
            panels.cloud.classList.toggle('active', s >= ranges[4][0] && s < ranges[4][1]);
            panels.data.classList.toggle('active', s >= ranges[5][0] && s < ranges[5][1]);
            panels.skills.classList.toggle('active', s >= ranges[6][0] && s < ranges[6][1]);
            panels.projects.classList.toggle('active', s >= ranges[7][0] && s < ranges[7][1]);
            panels.vision.classList.toggle('active', s >= ranges[8][0] && s < ranges[8][1]);
            panels.contact.classList.toggle('active', s >= ranges[9][0]);

            const newSection = Math.min(9, Math.floor(s * 10));
            if (newSection !== State.section) {
                State.section = newSection;
                applySectionVisibility(State.section);
            }

            markers.forEach((m, i) => m.classList.toggle('active', i === State.section));
        }

        // =====================
        // CONTROLLED SMOOTH SCROLL (ULTRA SMOOTH - SLOW SCROLL)
        // =====================
        const SCROLL_CTRL = {
            targetY: 0,
            currentY: 0,
            rafId: null,

            // üî• ULTRA SLOW settings for cinematic scroll
            wheelSpeed: 0.16,
            touchSpeed: 0.20,
            ease: 0.07,

            // safety
            epsilon: 0.2
        };

        function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }

        function maxScrollY() {
            return Math.max(0, document.documentElement.scrollHeight - window.innerHeight);
        }

        // Normalize wheel across devices (trackpad vs mouse)
        function normalizeWheelDelta(e) {
            let d = e.deltaY;

            // deltaMode: 0=pixel, 1=line, 2=page
            if (e.deltaMode === 1) d *= 16;                 // lines -> px
            if (e.deltaMode === 2) d *= window.innerHeight; // pages -> px

            // Clamp crazy spikes (mac trackpad inertia can be huge)
            d = clamp(d, -220, 220);
            return d;
        }

        function startScrollRaf() {
            if (SCROLL_CTRL.rafId) return;

            const step = () => {
                const maxY = maxScrollY();

                // Keep targets in bounds
                SCROLL_CTRL.targetY = clamp(SCROLL_CTRL.targetY, 0, maxY);

                // Ease toward target
                const diff = SCROLL_CTRL.targetY - SCROLL_CTRL.currentY;
                SCROLL_CTRL.currentY += diff * SCROLL_CTRL.ease;

                // Apply scroll
                window.scrollTo(0, SCROLL_CTRL.currentY);

                // Update progress mapping (your existing logic)
                onScroll();

                if (Math.abs(diff) > SCROLL_CTRL.epsilon) {
                    SCROLL_CTRL.rafId = requestAnimationFrame(step);
                } else {
                    // Snap final
                    SCROLL_CTRL.currentY = SCROLL_CTRL.targetY;
                    window.scrollTo(0, SCROLL_CTRL.currentY);
                    onScroll();

                    cancelAnimationFrame(SCROLL_CTRL.rafId);
                    SCROLL_CTRL.rafId = null;
                }
            };

            SCROLL_CTRL.rafId = requestAnimationFrame(step);
        }


        // Throttled scroll using requestAnimationFrame for smooth performance
        let scrollTicking = false;
        function onScroll() {
            if (!State.started) return;

            const scrollHeight = document.documentElement.scrollHeight - window.innerHeight;
            const scrollY = window.scrollY;

            // ‚úÖ no forced jump, just clamp progress
            State.targetProgress = (scrollHeight > 0)
                ? Math.max(0, Math.min(scrollY / scrollHeight, 1))
                : 0;
            if (scrollHint && State.targetProgress > 0.02) scrollHint.classList.add('hidden');
        }


        function throttledScroll() {
            if (!scrollTicking) {
                requestAnimationFrame(() => {
                    onScroll();
                    scrollTicking = false;
                });
                scrollTicking = true;
            }
        }

        // Keep scroll listener only for manual scrollbar dragging (mouse grabbing the bar, etc.)
        window.addEventListener('scroll', throttledScroll, { passive: true });

        // CONTROLLED WHEEL: Intercept and smooth out scroll for cinematic feel
        window.addEventListener('wheel', (e) => {
            if (!State.started) return;

            // Prevent default jumpy scrolling
            e.preventDefault();

            const delta = normalizeWheelDelta(e);
            const maxY = maxScrollY();

            // Apply ultra-slow multiplier for smooth cinematic scroll
            SCROLL_CTRL.targetY = clamp(
                SCROLL_CTRL.targetY + (delta * SCROLL_CTRL.wheelSpeed),
                0,
                maxY
            );
            startScrollRaf();
        }, { passive: false });


        markers.forEach(m => {
            m.addEventListener('click', () => {
                const section = parseInt(m.dataset.section);
                const scrollHeight = document.documentElement.scrollHeight - window.innerHeight;
                const target = (section / 10) * scrollHeight;
                window.scrollTo({ top: target, behavior: 'smooth' });
            });
        });

        const clock = new THREE.Clock();
        let cameraPos = new THREE.Vector3();
        let cameraTarget = new THREE.Vector3();

        function createCloudSection() {
            // If you later want clouds only in a specific section, you can toggle visibility here.
            return createCloudLayers();
        }

        let touchLastY = null;

        window.addEventListener('touchstart', (e) => {
            if (!State.started) return;
            touchLastY = e.touches?.[0]?.clientY ?? null;
            SCROLL_CTRL.currentY = window.scrollY;
            SCROLL_CTRL.targetY = window.scrollY;
        }, { passive: true });

        window.addEventListener('touchmove', (e) => {
            if (!State.started) return;
            if (touchLastY == null) return;

            // prevent fast native fling
            e.preventDefault();

            const y = e.touches?.[0]?.clientY ?? touchLastY;
            const delta = (touchLastY - y); // swipe up -> positive scroll
            touchLastY = y;

            const maxY = maxScrollY();
            SCROLL_CTRL.targetY = clamp(
                SCROLL_CTRL.targetY + (delta * SCROLL_CTRL.touchSpeed),
                0,
                maxY
            );
            startScrollRaf();
        }, { passive: false });

        window.addEventListener('touchend', () => {
            touchLastY = null;
        }, { passive: true });


        let sunSprite = null;

        function makeSunTexture() {
            const c = document.createElement('canvas');
            c.width = 256; c.height = 256;
            const ctx = c.getContext('2d');

            // Tighter, more realistic sun disc ‚Äî bright core, fast falloff
            const g = ctx.createRadialGradient(128, 128, 0, 128, 128, 100);
            g.addColorStop(0.00, 'rgba(255, 245, 220, 1.0)');  // bright warm-white core
            g.addColorStop(0.08, 'rgba(255, 225, 170, 0.9)');  // warm edge of disc
            g.addColorStop(0.20, 'rgba(255, 190, 100, 0.35)'); // corona
            g.addColorStop(0.50, 'rgba(255, 160, 80, 0.08)');  // faint glow
            g.addColorStop(1.00, 'rgba(255, 140, 60, 0.0)');   // transparent

            ctx.fillStyle = g;
            ctx.fillRect(0, 0, 256, 256);

            const tex = new THREE.CanvasTexture(c);
            tex.colorSpace = THREE.SRGBColorSpace;
            tex.needsUpdate = true;
            return tex;
        }

        function createSunSprite(sunDirVec3) {
            const tex = makeSunTexture();
            const mat = new THREE.SpriteMaterial({
                map: tex,
                transparent: true,
                depthWrite: false,
                depthTest: false,
                blending: THREE.AdditiveBlending,
                opacity: SCENE_CONFIG.sunSpriteOpacity
            });

            const sprite = new THREE.Sprite(mat);
            sprite.position.copy(sunDirVec3).multiplyScalar(SCENE_CONFIG.sunSpriteDistance);
            sprite.scale.setScalar(SCENE_CONFIG.sunSpriteScale);
            return sprite;
        }


        function init() {
            scene = new THREE.Scene();
            // üå´Ô∏è Subtle atmospheric haze (blue-grey, NOT orange ‚Äî keeps scene readable)
            scene.fog = new THREE.FogExp2(SCENE_CONFIG.fogColor, SCENE_CONFIG.fogDensity);
            ensureWorldGroups();


            // 1) Camera FIRST
            const baseFov = State.isMobile ? 65 : 55;
            camera = new THREE.PerspectiveCamera(
                baseFov,
                window.innerWidth / window.innerHeight,
                1,        // ‚úÖ raise near plane
                2800      // far plane kept tighter to reduce unnecessary fill cost
            );


            const startPos = samplePathPoint(getCameraPath(), 0);
            const startLook = samplePathPoint(getLookAtPath(), 0);
            camera.position.copy(startPos);
            cameraPos.copy(camera.position);
            cameraTarget.copy(startLook);
            camera.userData.baseFov = baseFov;
            createCloudLayers();
            if (cloudManager) {
                applyCloudCurtainState('HOME_IDLE');
                // Ensure HOME curtain is visible on the very first rendered frame.
                cloudManager.update({
                    deltaSeconds: 0.016,
                    elapsedSeconds: 0,
                    progress: 0,
                    progressVelocity: 0,
                    streamReadiness: 0
                });
            }

            // 2) Renderer SECOND
            const quality = getQualitySettings();
            renderer = new THREE.WebGLRenderer({
                antialias: State.qualityTier === 'HIGH', // Only antialias on HIGH
                alpha: true,
                powerPreference: 'high-performance',
                preserveDrawingBuffer: false
            });

            renderer.setSize(window.innerWidth, window.innerHeight);
            State.currentDpr = Math.min(window.devicePixelRatio, quality.dprCap, MAX_RENDER_DPR);
            renderer.setPixelRatio(State.currentDpr);

            renderer.toneMapping = State.qualityTier === 'LOW' ? SCENE_CONFIG.toneMappingLow : SCENE_CONFIG.toneMapping;
            renderer.toneMappingExposure = State.qualityTier === 'LOW' ? SCENE_CONFIG.exposureLow : SCENE_CONFIG.exposure;



            renderer.outputColorSpace = THREE.SRGBColorSpace;
            // r160: physically correct lights is the default; use useLegacyLights for LOW tier
            renderer.useLegacyLights = (State.qualityTier === 'LOW');

            renderer.shadowMap.enabled = false; // DISABLED: Shadows too expensive for MacBook Air
            // renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            canvasContainer.appendChild(renderer.domElement);

            // 3) Composer (post-processing) - DISABLED for MacBook Air performance
            const usePost = false; // Force disable bloom for all devices to prevent thermal throttling

            // Only enable bloom on desktop HIGH tier with dedicated GPU
            const hasDedicatedGPU = (() => {
                const canvas = document.createElement('canvas');
                const gl = canvas.getContext('webgl');
                if (!gl) return false;
                const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                if (!debugInfo) return false;
                const renderer = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
                return /NVIDIA|AMD|RTX|GTX|Radeon/.test(renderer);
            })();

            const shouldUseBloom = (State.qualityTier === 'HIGH') && quality.enableBloom && !State.isMobile && hasDedicatedGPU;

            if (shouldUseBloom) {
                const bloomWidth = Math.floor(window.innerWidth * 0.5); // Reduced from 0.75
                const bloomHeight = Math.floor(window.innerHeight * 0.5);

                composer = new EffectComposer(renderer);
                composer.addPass(new RenderPass(scene, camera));

                bloomPass = new UnrealBloomPass(
                    new THREE.Vector2(bloomWidth, bloomHeight),
                    0.12,  // reduced strength
                    0.4,   // tighter radius
                    0.94   // higher threshold
                );

                composer.addPass(bloomPass);
                console.log(`üåü Bloom enabled at ${bloomWidth}x${bloomHeight} (dedicated GPU detected)`);
            } else {
                composer = null;
                bloomPass = null;
                console.log(`üåü Bloom disabled (${State.qualityTier} tier, dedicated GPU: ${hasDedicatedGPU})`);
            }

            // HDRI Environment (only on HIGH to save GPU/RAM)
            // Polyhaven only serves 1k/2k/4k/8k ‚Äî no 512 variant exists
            if (State.qualityTier === 'HIGH') {
                const hdriUrl = 'https://dl.polyhaven.org/file/ph-assets/HDRIs/hdr/1k/hamburg_hbf_1k.hdr';

                new RGBELoader()
                    .load(hdriUrl, (texture) => {
                        texture.mapping = THREE.EquirectangularReflectionMapping;
                        scene.environment = texture;
                        scene.background = null;
                        console.log('‚úÖ HDRI environment loaded');
                    }, undefined, (err) => {
                        console.warn('‚ö†Ô∏è HDRI load failed, scene will use sky + lights only:', err?.message || err);
                    });
            }



            const sky = new Sky();
            sky.scale.setScalar(450000);
            scene.add(sky);

            // üåá Sunset sky setup
            const sun = new THREE.Vector3();
            const uniforms = sky.material.uniforms;

            // Clean golden-hour sky (lower turbidity = clearer, less muddy)
            uniforms['turbidity'].value = SCENE_CONFIG.skyTurbidity;
            uniforms['rayleigh'].value = SCENE_CONFIG.skyRayleigh;
            uniforms['mieCoefficient'].value = SCENE_CONFIG.skyMieCoefficient;
            uniforms['mieDirectionalG'].value = SCENE_CONFIG.skyMieDirectionalG;

            // Golden hour sun position
            const elevation = SCENE_CONFIG.sunElevation;
            const azimuth = SCENE_CONFIG.sunAzimuth;

            const phi = THREE.MathUtils.degToRad(90 - elevation);
            const theta = THREE.MathUtils.degToRad(azimuth);
            sun.setFromSphericalCoords(1, phi, theta);

            uniforms['sunPosition'].value.copy(sun);

            // Sun directional light ‚Äî warm white, not deep orange
            const sunLight = new THREE.DirectionalLight(SCENE_CONFIG.sunLightColor, SCENE_CONFIG.sunLightIntensity);
            sunLight.castShadow = (State.qualityTier !== 'LOW');
            sunLight.position.copy(sun).multiplyScalar(800);
            scene.add(sunLight);

            // Sun disc sprite ‚Äî controlled size, not a blown-out blob
            if (sunSprite) scene.remove(sunSprite);
            sunSprite = createSunSprite(sun);
            sunSprite.material.opacity = SCENE_CONFIG.sunSpriteOpacity;
            scene.add(sunSprite);

            // Hemisphere fill ‚Äî warm sky / cool-blue ground (lifts shadows, adds depth)
            const hemiIntensity = State.qualityTier === 'LOW' ? SCENE_CONFIG.hemiIntensityLow : SCENE_CONFIG.hemiIntensity;
            const fillLight = new THREE.HemisphereLight(
                SCENE_CONFIG.hemiSkyColor,
                SCENE_CONFIG.hemiGroundColor,
                hemiIntensity
            );
            scene.add(fillLight);

            // Ambient fill ‚Äî prevents black silhouettes (critical for LOW tier without env map)
            const ambIntensity = State.qualityTier === 'LOW' ? SCENE_CONFIG.ambientIntensityLow : SCENE_CONFIG.ambientIntensity;
            const ambientLight = new THREE.AmbientLight(SCENE_CONFIG.ambientColor, ambIntensity);
            scene.add(ambientLight);
            // Ground (realistic terrain with grass and river)
            groundMesh = createGround();
            // Note: createGround() now adds to scene internally, no need to add again

            // Scene assets
            createRealisticEiffelTower();
            createHeroForegroundSet();
            createCity();
            createTrees();
            createMountains();

            // HOME should never expose unloaded/backfill chunks.
            setBackgroundVisibility(false);
            bgRevealLocked = true;
            bgGateState.assetsLoaded = modelLoadingState.ready;
            bgGateState.compiled = false;
            bgGateState.ready = false;
            bgGateState.revealDeadlineMs = 0;
            bgGateState.timedOut = false;

            // Warm streamed stages near the initial camera corridor before interaction starts.
            prewarmStreamingAtHome();
            enforceMeshCulling(scene);
            logStreamingDebug('post-build');
            createDataSection();
            createSkillsSection();
            createScooter();
            createParticles();

            // Text animations
            splitText();

            // Initial section visibility
            applySectionVisibility(0);

            console.log('‚ú® Scene Initialized (Fixed init order + no duplicate composer)');
        }

        let isPaused = false;

        document.addEventListener('visibilitychange', () => {
            const hidden = document.visibilityState !== 'visible';
            isPaused = hidden;

            if (hidden) {
                // stop motion + reduce work
                State.frameInterval = 1000 / 20; // ~20fps
            } else {
                State.frameInterval = 1000 / 60;
                State.lastFrameTime = performance.now();
            }
        });

        // ‚úÖ Track user input for idle detection
        function markActive() { State.lastInputTime = performance.now(); }
        window.addEventListener('wheel', markActive, { passive: true });
        window.addEventListener('touchstart', markActive, { passive: true });
        window.addEventListener('touchmove', markActive, { passive: true });
        window.addEventListener('keydown', markActive, { passive: true });



        // Hover effects ONLY for data spheres (not buildings)
        function applyHoverEffect(object) {
            if (!object || !object.material) return;
            if (object.material.emissive) {
                object.material.emissive.setHex(0xff6b35);
                object.material.emissiveIntensity = 0.18;
            }
            object.scale.copy(object.userData.originalScale).multiplyScalar(1.12);
        }

        function resetHoverEffect(object) {
            if (!object || !object.material) return;
            if (object.material.emissive) {
                object.material.emissive.setHex(object.userData.originalEmissive || 0x000000);
                object.material.emissiveIntensity = 0;
            }
            if (object.userData.originalScale) object.scale.copy(object.userData.originalScale);
        }


        function applyQualityTier(newTier) {
            if (State.userForcedTier) return;
            if (!newTier || newTier === State.qualityTier) return;

            State.qualityTier = newTier;
            const q = getQualitySettings();

            console.log(`‚öôÔ∏è Switching quality tier ‚Üí ${newTier}`);

            State.currentDpr = Math.min(window.devicePixelRatio, q.dprCap, MAX_RENDER_DPR);
            if (renderer) renderer.setPixelRatio(State.currentDpr);
            if (renderer) renderer.shadowMap.enabled = newTier !== 'LOW';
            if (bloomPass) bloomPass.enabled = (q.enableBloom && !State.isMobile && newTier !== 'LOW');

            // Swap tone mapping for cheaper rendering at LOW
            if (renderer) {
                renderer.toneMapping = newTier === 'LOW' ? SCENE_CONFIG.toneMappingLow : SCENE_CONFIG.toneMapping;
                renderer.toneMappingExposure = newTier === 'LOW' ? SCENE_CONFIG.exposureLow : SCENE_CONFIG.exposure;
                renderer.useLegacyLights = (newTier === 'LOW');
            }

            // Rebuild materials for new tier (swap transmission ‚Üí standard at LOW)
            const oldMaterials = MATERIALS;
            MATERIALS = createMaterials(newTier);

            // Swap river mesh material in terrain group
            if (groups.terrain) {
                groups.terrain.traverse((child) => {
                    if (child.isMesh && child.name === 'river') {
                        if (child.material) child.material.dispose();
                        child.material = MATERIALS.river;
                    }
                });
            }

            // Hide excess buildings beyond new buildingCount
            if (cityInstances && cityInstances.length > q.buildingCount) {
                for (let i = q.buildingCount; i < cityInstances.length; i++) {
                    cityInstances[i].visible = false;
                }
            }

            // Refresh streaming bands so thresholds match the active tier.
            const cityBands = getStreamingBands('city');
            for (let i = 0; i < cityLods.length; i++) {
                const d = cityLods[i].userData?.stream;
                if (d) d.bands = cityBands;
            }
            for (let i = 0; i < cityZones.length; i++) {
                cityZones[i].maxFarStart = cityBands.farStart;
            }

            const treeBands = getStreamingBands('tree');
            for (let i = 0; i < treeLods.length; i++) {
                const d = treeLods[i].userData?.stream;
                if (d) d.bands = treeBands;
            }
            for (let i = 0; i < treeZones.length; i++) {
                treeZones[i].maxFarStart = treeBands.farStart;
            }
            for (let i = 0; i < treeProxyZones.length; i++) {
                treeProxyZones[i].farStart = treeBands.farStart;
            }
            if (cloudManager) cloudManager.setQualityTier(newTier);

            // Dispose old transmission materials
            if (oldMaterials) {
                ['glass', 'cheapGlass', 'river'].forEach(key => {
                    if (oldMaterials[key] && oldMaterials[key] !== MATERIALS[key]) {
                        oldMaterials[key].dispose();
                    }
                });
            }

            logStreamingDebug('tier-switch');
        }


        function monitorFpsAndAutoDowngrade() {
            const now = performance.now();
            if (now - State.fpsLastSampleTs < 2000) return; // sample every 2s
            State.fpsLastSampleTs = now;

            // Calculate median FPS from recent samples
            State.fpsSamples.push(State.fps);
            if (State.fpsSamples.length > 5) State.fpsSamples.shift();

            const sorted = [...State.fpsSamples].sort((a, b) => a - b);
            const median = sorted[Math.floor(sorted.length / 2)];

            // Adaptive DPR: scale resolution based on FPS headroom
            const quality = getQualitySettings();
            const maxDpr = Math.min(window.devicePixelRatio, quality.dprCap, MAX_RENDER_DPR);
            if (renderer && median > 0) {
                if (median > 52 && State.currentDpr < maxDpr) {
                    // FPS headroom ‚Äî raise DPR for clarity
                    State.currentDpr = Math.min(State.currentDpr + 0.04, maxDpr);
                    renderer.setPixelRatio(State.currentDpr);
                } else if (median < 35 && State.currentDpr > State.dprFloor) {
                    // FPS struggling ‚Äî lower DPR to recover
                    State.currentDpr = Math.max(State.currentDpr - 0.1, State.dprFloor);
                    renderer.setPixelRatio(State.currentDpr);
                    console.log(`üìâ Adaptive DPR: lowered to ${State.currentDpr.toFixed(2)} (FPS median: ${median.toFixed(0)})`);
                }
            }

            if (median < 24) {
                State.lowFpsStrikes++;
            } else {
                State.lowFpsStrikes = Math.max(0, State.lowFpsStrikes - 1);
            }

            // 3 consecutive low-FPS samples ‚Üí downgrade one tier
            if (State.lowFpsStrikes >= 3) {
                State.lowFpsStrikes = 0;
                State.fpsSamples.length = 0;
                const tiers = ['LOW', 'MEDIUM', 'HIGH'];
                const idx = tiers.indexOf(State.qualityTier);
                if (idx > 0) {
                    console.log(`‚ö†Ô∏è FPS too low (median ${median.toFixed(0)}), downgrading from ${State.qualityTier} to ${tiers[idx - 1]}`);
                    applyQualityTier(tiers[idx - 1]);
                }
            }
        }



        let _idleRAF = null;
        function scheduleNextFrame() {
            const idleThreshold = 2000; // 2 seconds of no input
            const timeSinceInput = performance.now() - State.lastInputTime;
            const wasIdle = State.isIdle;
            State.isIdle = timeSinceInput > idleThreshold;
            const sceneStatic =
                Math.abs(State.targetProgress - State.progress) < 0.00035 &&
                sceneFlow.state !== SceneState.TRANSITION;

            if (State.isIdle || sceneStatic) {
                // Lower cadence when static to cut GPU load.
                const delay = sceneStatic ? 130 : 100;
                _idleRAF = setTimeout(() => requestAnimationFrame(animate), delay);
            } else {
                if (wasIdle && !State.isIdle) {
                    // Resuming from idle ‚Äî reset frame timing to avoid large delta
                    State.lastFrameTime = performance.now();
                }
                requestAnimationFrame(animate);
            }
        }

        function animate(currentTime) {
            scheduleNextFrame();

            // ‚úÖ skip rendering entirely when tab is hidden ‚Äî no one can see it
            if (isPaused) return;

            // DEBUG: Log performance every 60 frames (remove in production)
            if (Math.floor(currentTime / 1000) % 5 === 0 && Math.random() < 0.01) {
                console.log('üìä Performance:', {
                    tier: State.qualityTier,
                    dpr: renderer.getPixelRatio(),
                    drawCalls: renderer.info.render.calls,
                    triangles: renderer.info.render.triangles,
                    textures: renderer.info.memory.textures,
                    geometries: renderer.info.memory.geometries
                });
            }

            // =====================
            // FRAME RATE LIMITING (60 FPS target)
            // =====================
            // Handle first frame where currentTime may be undefined
            if (!currentTime) {
                State.lastFrameTime = performance.now();
                return;
            }

            const deltaTime = currentTime - State.lastFrameTime;



            // Skip if running too fast (but always allow first valid frame)
            if (deltaTime < State.frameInterval && State.lastFrameTime > 0) {
                return;
            }
            State.lastFrameTime = currentTime - (deltaTime % State.frameInterval);

            // ‚úÖ Track FPS for auto-downgrade
            if (deltaTime > 0) State.fps = 1000 / deltaTime;
            monitorFpsAndAutoDowngrade();

            // Frame-rate independent easing (guard against NaN)
            const safeDelta = isNaN(deltaTime) || deltaTime <= 0 ? 16.67 : deltaTime;
            const frameFactor = Math.min(safeDelta / 16.67, 2); // Normalize to ~60fps, cap at 2x
            const baseEase = State.isMobile ? 0.06 : 0.045;
            const ease = baseEase * frameFactor;
            State.progress += (State.targetProgress - State.progress) * ease;

            // Clamp progress to valid range
            State.progress = Math.max(0, Math.min(State.progress, 0.9999));

            updatePanels();
            if (progressThumb) progressThumb.style.height = `${Math.round(State.progress * 100)}%`;

            const t = State.progress;
            const elapsed = clock.getElapsedTime();
            const nowMs = performance.now();

            // Camera animation
            if (State.started) {
                const cameraPath = getCameraPath();
                const lookAtPath = getLookAtPath();

                const targetPos = samplePathPoint(cameraPath, t);
                const targetLookAt = samplePathPoint(lookAtPath, t);
                const lookAhead = samplePathPoint(cameraPath, t + CAMERA_PATH_TUNING.lookAheadT);
                targetLookAt.lerp(lookAhead, CAMERA_PATH_TUNING.lookAtForwardBlend);

                // Frame-rate independent lerping (buttery smooth)
                const lerpFactor = SCENE_CONFIG.cameraDamping * frameFactor;
                cameraPos.lerp(targetPos, Math.min(lerpFactor, SCENE_CONFIG.cameraDampingMax));
                cameraTarget.lerp(targetLookAt, Math.min(lerpFactor, SCENE_CONFIG.cameraDampingMax));

                // Keep camera outside buildings and above terrain for cleaner cinematic paths.
                applyCameraCollisionSafety(cameraPos);

                // Clamp lookAt Y range
                cameraTarget.y = THREE.MathUtils.clamp(
                    cameraTarget.y,
                    SCENE_CONFIG.lookAtYClampMin,
                    SCENE_CONFIG.lookAtYClampMax
                );

                camera.position.copy(cameraPos);
                camera.lookAt(cameraTarget);
                const prevProgress = State.lastProgress ?? State.progress;
                const progressVelocity = State.progress - prevProgress;
                updateSceneStateMachine(nowMs, progressVelocity);
                applyCloudCurtainState(cloudCurtainState);

                const cloudState = cloudManager ? cloudManager.update({
                    deltaSeconds: safeDelta / 1000,
                    elapsedSeconds: elapsed,
                    progress: State.progress,
                    progressVelocity,
                    streamReadiness: State.streamingReadiness || 0
                }) : null;

                if (scene.fog) {
                    let targetFogDensity = SCENE_CONFIG.fogDensity;
                    if (cloudCurtainState === 'HOME_IDLE') {
                        targetFogDensity = HOME_FOG_DENSITY;
                    } else if (cloudCurtainState === 'TRANSITION_MASK') {
                        targetFogDensity = TRANSITION_FOG_DENSITY;
                    } else if (cloudCurtainState === 'TRANSITION_REVEAL') {
                        targetFogDensity = REVEAL_FOG_DENSITY;
                    }
                    if (cloudState?.maskStrength !== undefined) {
                        const fadeOutFactor = THREE.MathUtils.lerp(0.78, 1.0, cloudState.maskStrength);
                        targetFogDensity *= fadeOutFactor;
                    }
                    scene.fog.density += (targetFogDensity - scene.fog.density) * Math.min(FOG_TRANSITION_DAMP * frameFactor, 1);
                }

                const worldStreamingState = worldStreamingManager ? worldStreamingManager.update({
                    progress: State.progress,
                    cloudState,
                    streamReadiness: State.streamingReadiness || 0
                }) : null;
                const streamVisibilityGate = worldStreamingState?.streamVisibilityGate || null;

                if (debugHud && nowMs - debugHudLastMs > 120) {
                    debugHudLastMs = nowMs;
                    const fogDensity = scene?.fog?.density || 0;
                    const cloudMask = cloudState?.maskStrength || 0;
                    const cloudNear = cloudState?.nearOpacity || 0;
                    const cloudFar = cloudState?.farOpacity || 0;
                    debugHud.textContent =
                        `progress: ${State.progress.toFixed(3)}\\n` +
                        `sceneState: ${sceneFlow.state}\\n` +
                        `curtain: ${cloudCurtainState}\\n` +
                        `cloudMask: ${cloudMask.toFixed(3)}\\n` +
                        `cloudNear/Far: ${cloudNear.toFixed(3)} / ${cloudFar.toFixed(3)}\\n` +
                        `fogDensity: ${fogDensity.toFixed(5)}\\n` +
                        `bgReady/timeout/visible: ${bgGateState.ready ? 1 : 0} / ${bgGateState.timedOut ? 1 : 0} / ${(groups.bgRoot?.visible) ? 1 : 0}\\n` +
                        `modelsLoaded: ${modelLoadingState.loadedModels}/${modelLoadingState.totalModels}`;
                }

                // Staged city/tree streaming update with hysteresis.
                const hasCityZones = cityZones.length > 0 && groups.city && groups.city.visible;
                const hasTreeZones = treeZones.length > 0 && groups.trees && groups.trees.visible;
                const hasTreeProxyZones = treeProxyZones.length > 0 && groups.trees && groups.trees.visible;

                if (hasCityZones || hasTreeZones || hasTreeProxyZones) {
                    const low = State.qualityTier === 'LOW';
                    const shouldPrioritizeStreaming = !!worldStreamingState?.prioritizeStreaming;
                    const shouldUpdateStreams = shouldPrioritizeStreaming || !low || (Math.floor(currentTime / 95) % 2 === 0);

                    if (shouldUpdateStreams) {
                        _projMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
                        _frustum.setFromProjectionMatrix(_projMatrix);

                        if (hasCityZones) updateStreamZones(cityZones, camera, nowMs, streamVisibilityGate);
                        if (hasTreeZones) updateStreamZones(treeZones, camera, nowMs, streamVisibilityGate);

                        if (hasTreeProxyZones) {
                            const treeBands = getStreamingBands('tree');
                            const farSq = treeBands.farStart * treeBands.farStart;
                            const hysteresisScale = 1 + (treeBands.hysteresis || 0.10);
                            const proxyScale = streamVisibilityGate?.enabled ? (streamVisibilityGate.treeProxyScale || 1) : 1;

                            for (let i = 0; i < treeProxyZones.length; i++) {
                                const zone = treeProxyZones[i];
                                _sphere.set(zone.center, zone.radius + treeBands.farStart * 0.25);
                                const frustumVisible = _frustum.intersectsSphere(_sphere);

                                if (!frustumVisible) {
                                    zone.group.visible = false;
                                    zone.visibleLastFrame = false;
                                    continue;
                                }

                                const dx = zone.center.x - camera.position.x;
                                const dz = zone.center.z - camera.position.z;
                                const d2 = dx * dx + dz * dz;
                                const baseSq = zone.visibleLastFrame ? (farSq * hysteresisScale * hysteresisScale) : farSq;
                                const maxSq = baseSq * proxyScale * proxyScale;
                                zone.group.visible = d2 <= maxSq;
                                zone.visibleLastFrame = zone.group.visible;
                            }
                        }
                    }
                }

                updateStreamTransitions(nowMs);
                State.streamingReadiness = computeStreamingReadiness(nowMs);


                const velocity = Math.abs(progressVelocity);
                State.lastProgress = State.progress;

                const baseFov = camera.userData.baseFov || 55;
                const targetFov = baseFov + Math.min(velocity * 450, State.isMobile ? 6 : 12);
                camera.fov += (targetFov - camera.fov) * 0.05 * frameFactor;
                camera.updateProjectionMatrix();
            }

            // Culling update (vanish logic)
            updateCityCulling(nowMs);

            // REMOVED: Raycaster hover effects - data spheres removed
            // Only using loaded GLB models, no interactive hover elements

            // Eiffel beacon - only when visible
            if (eiffelTower && eiffelTower.userData.spot && groups.eiffel && groups.eiffel.visible) {
                const time = Date.now() * 0.001;
                const spot = eiffelTower.userData.spot;
                spot.target.position.x = Math.sin(time) * 100;
                spot.target.position.z = Math.cos(time) * 100;
                spot.target.updateMatrixWorld();
            }

            // REMOVED: Particle and data sphere animation - only loaded models used

            // Scooter - only when visible
            if (scooter && scooter.visible) {
                const st = (t - 0.15) / 0.17;
                scooter.position.x = -150 + st * 200;
                scooter.position.z = 100 - st * 100;
                scooter.rotation.y = Math.PI / 4 + Math.sin(elapsed * 4) * 0.015;
            }

            // Render (desktop composer OR mobile renderer)
            if (composer) composer.render();
            else renderer.render(scene, camera);
        }


        // Resize handler with debouncing - OPTIMIZED
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                const wasMobile = State.isMobile;
                State.isMobile = window.innerWidth < 768;
                if (!camera || !renderer) return;

                // Update camera
                camera.aspect = window.innerWidth / window.innerHeight;

                if (wasMobile !== State.isMobile) {
                    const newBaseFov = State.isMobile ? 65 : 55;
                    camera.fov = newBaseFov;
                    camera.userData.baseFov = newBaseFov;
                }

                camera.updateProjectionMatrix();

                // Update renderer - FORCE DPR to 1.0 on resize for MacBook Air
                const q = getQualitySettings();
                const dpr = Math.min(window.devicePixelRatio, q.dprCap, MAX_RENDER_DPR, State.qualityTier === 'LOW' ? 1.0 : q.dprCap);
                renderer.setPixelRatio(dpr);
                renderer.setSize(window.innerWidth, window.innerHeight);

                if (composer) composer.setSize(window.innerWidth, window.innerHeight);

            }, 250); // Increased debounce for better performance
        });

        window.addEventListener('orientationchange', () => {
            setTimeout(() => window.dispatchEvent(new Event('resize')), 220);
        });

        // GPU Warm-up
        function warmUpGPU(callback) {
            let warmUpFrames = 0;
            const maxWarmUpFrames = 8;

            function warmUpLoop() {
                if (warmUpFrames < maxWarmUpFrames) {
                    warmUpFrames++;
                    if (composer) composer.render();
                    else renderer.render(scene, camera);
                    requestAnimationFrame(warmUpLoop);
                } else callback();
            }
            warmUpLoop();
        }


        // Startup logic
        let sceneReady = false;

        async function initializeScene() {
            try {
                await loadAllModels();
                init();
                bgGateState.assetsLoaded = modelLoadingState.ready;
                await compileBackgroundAssets();
                injectContent();
                sceneReady = true;
                console.log('‚ú® Scene ready with normalized models');
            } catch (e) {
                console.error("Init Error:", e);
                if (startBtn) {
                    startBtn.disabled = false;
                    startBtn.textContent = 'START';
                }
            }
        }
        initializeScene();

        function startExperience() {
            if (State.started) return;
            if (!sceneReady) return;

            // ‚úÖ Hard reset scroll + progress at the moment START is pressed
            window.scrollTo(0, 0);
            SCROLL_CTRL.currentY = 0;
            SCROLL_CTRL.targetY = 0;

            State.progress = 0;
            State.targetProgress = 0;
            State.lastProgress = 0;
            State.section = 0;
            State.streamingReadiness = 0;
            sceneFlow.state = SceneState.BOOT_LOADING;
            sceneFlow.lastSection = 0;
            sceneFlow.bootDeadlineMs = performance.now() + SCENE_FLOW_CONFIG.bootTimeoutMs;
            sceneFlow.transition.active = false;
            sceneFlow.transition.fromSection = 0;
            sceneFlow.transition.toSection = 0;
            sceneFlow.transition.startMs = 0;
            sceneFlow.transition.deadlineMs = 0;
            bgRevealLocked = true;
            setBackgroundVisibility(false);
            bgGateState.revealDeadlineMs = 0;
            bgGateState.timedOut = false;
            cloudCurtainState = 'HOME_IDLE';
            previousCloudCurtainState = 'OFF';
            if (cloudManager) cloudManager.resetForLanding();
            if (worldStreamingManager) worldStreamingManager.reset();
            prewarmStreamingAtHome();
            applyCloudCurtainState('HOME_IDLE');
            if (cloudManager) {
                cloudManager.update({
                    deltaSeconds: 0.016,
                    elapsedSeconds: 0,
                    progress: 0,
                    progressVelocity: 0,
                    streamReadiness: 0
                });
            }

            State.started = true;

            onScroll();
            updatePanels();



            if (startBtn) {
                startBtn.disabled = true;
                startBtn.style.pointerEvents = 'none';
                startBtn.textContent = 'STARTING...';
            }

            warmUpGPU(() => {
                document.body.classList.add('experience-active');

                loader.style.transition = 'opacity 0.8s cubic-bezier(0.4, 0, 0.2, 1)';
                loader.style.opacity = '0';

                setTimeout(() => {
                    loader.classList.add('hidden');

                    requestAnimationFrame(() => {
                        canvasContainer.style.transition = 'opacity 1.2s cubic-bezier(0.4, 0, 0.2, 1)';
                        canvasContainer.classList.add('visible');

                        animate();

                        setTimeout(() => nav.classList.add('visible'), 200);
                        setTimeout(() => {
                            progressContainer.classList.add('visible');
                            sectionMarkers.classList.add('visible');
                        }, 400);

                        setTimeout(() => {
                            uiLayer.classList.add('visible');
                            if (panels.hero) panels.hero.classList.add('active');
                        }, 600);

                        setTimeout(() => scrollHint.classList.add('visible'), 1200);
                    });
                }, 800);
            });
        }

        if (startBtn) {
            startBtn.addEventListener('click', startExperience);
            startBtn.addEventListener('touchstart', startExperience, { passive: true });
        }

        document.addEventListener('keydown', (e) => {
            if (!State.started && sceneReady && (e.code === 'Space' || e.code === 'Enter')) {
                e.preventDefault();
                startExperience();
            }
        });

        console.log('‚úÖ Ready');
    </script>
</body>

</html>
